<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Tao.Platform.Windows</name>
    </assembly>
    <members>
        <member name="T:Tao.Platform.Windows.WinNt">
            <summary>
                WinNT binding for .NET, implementing Windows NT-specific functionality.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_386">
            <summary>
                Intel i386 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_486">
            <summary>
                Intel i486 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_PENTIUM">
            <summary>
                Intel Pentium processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_IA64">
            <summary>
                Intel IA64 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_AMD_X8664">
            <summary>
                AMD X86 64 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_MIPS_R4000">
            <summary>
                MIPS R4000, R4101, R3910 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ALPHA_21064">
            <summary>
                Alpha 210 64 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_PPC_601">
            <summary>
                PPC 601 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_PPC_603">
            <summary>
                PPC 603 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_PPC_604">
            <summary>
                PPC 604 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_PPC_620">
            <summary>
                PPC 620 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_HITACHI_SH3">
            <summary>
                Hitachi SH3 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_HITACHI_SH3E">
            <summary>
                Hitachi SH3E processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_HITACHI_SH4">
            <summary>
                Hitachi SH4 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_MOTOROLA_821">
            <summary>
                Motorola 821 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_SHx_SH3">
            <summary>
                SHx SH3 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_SHx_SH4">
            <summary>
                SHx SH4 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_STRONGARM">
            <summary>
                StrongARM processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARM720">
            <summary>
                ARM 720 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARM820">
            <summary>
                ARM 820 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARM920">
            <summary>
                ARM 920 processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARM_7TDMI">
            <summary>
                ARM 7TDMI processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_OPTIL">
            <summary>
                MSIL processor.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_INTEL">
            <summary>
                Intel architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_MIPS">
            <summary>
                MIPS architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_ALPHA">
            <summary>
                Alpha architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_PPC">
            <summary>
                PPC architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_SHX">
            <summary>
                SHX architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_ARM">
            <summary>
                ARM architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_IA64">
            <summary>
                IA64 architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_ALPHA64">
            <summary>
                Alpha64 architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_MSIL">
            <summary>
                MSIL architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_AMD64">
            <summary>
                AMD64 architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_IA32_ON_WIN64">
            <summary>
                IA32 On Win64 architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_UNKNOWN">
            <summary>
                Unknown architecture.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_FLOATING_POINT_PRECISION_ERRATA">
            <summary>
                In rare circumstances, on a Pentium, a floating-point precision error can occur.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_FLOATING_POINT_EMULATED">
            <summary>
                Floating-point operations are emulated using a software emulator.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_COMPARE_EXCHANGE_DOUBLE">
            <summary>
                The compare and exchange double operation is available (Pentium, MIPS, and Alpha).
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_MMX_INSTRUCTIONS_AVAILABLE">
            <summary>
                The MMX instruction set is available.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_PPC_MOVEMEM_64BIT_OK">
            <summary>
                Unknown.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_ALPHA_BYTE_INSTRUCTIONS">
            <summary>
                Unknown.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_XMMI_INSTRUCTIONS_AVAILABLE">
            <summary>
                The SSE instruction set is available.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_3DNOW_INSTRUCTIONS_AVAILABLE">
            <summary>
                The 3D-Now instruction set is available.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_RDTSC_INSTRUCTION_AVAILABLE">
            <summary>
                The RDTSC instruction is available.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_PAE_ENABLED">
            <summary>
                The processor is PAE-enabled.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.WinNt.PF_XMMI64_INSTRUCTIONS_AVAILABLE">
            <summary>
                The SSE2 instruction set is available.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Kernel">
            <summary>
                Kernel binding for .NET, implementing Windows-specific kernel functionality.
            </summary>
            <remarks>
                Binds functions and definitions in kernel32.dll.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.KERNEL_NATIVE_LIBRARY">
            <summary>
                Specifies Kernel32's native library archive.
            </summary>
            <remarks>
                Specifies kernel32.dll for Windows.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.StdCall"/>.
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.Beep(System.Int32,System.Int32)">
            <summary>
                The <b>Beep</b> function generates simple tones on the speaker.  The function is
                synchronous; it does not return control to its caller until the sound finishes.
            </summary>
            <param name="frequency">
                <para>
                    Frequency of the sound, in hertz.  This parameter must be in the range
                    37 through 32,767 (0x25 through 0x7FFF).
                </para>
                <para>
                    <b>Windows 95/98/Me:</b>  The <b>Beep</b> function ignores this parameter.
                </para>
            </param>
            <param name="duration">
                <para>
                    Duration of the sound, in milliseconds.
                </para>
                <para>
                    <b>Windows 95/98/Me:</b>  The <b>Beep</b> function ignores this parameter.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    <b>Terminal Services:</b>  The beep is redirected to the client.
                </para>
                <para>
                    <b>Windows 95/98/Me:</b>  On computers with a sound card, the function
                    plays the default sound event.  On computers without a sound card, the
                    function plays the standard system beep.
                </para>
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.FreeLibrary(System.IntPtr)">
            <summary>
                The <b>FreeLibrary</b> function decrements the reference count of the loaded
                dynamic-link library (DLL).  When the reference count reaches zero, the module
                is unmapped from the address space of the calling process and the handle is no
                longer valid.
            </summary>
            <param name="moduleHandle">
                Handle to the loaded DLL module.  The <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/> or
                <see cref="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)"/> function returns this handle.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    Each process maintains a reference count for each loaded library module.  This
                    reference count is incremented each time <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/> is called
                    and is decremented each time <b>FreeLibrary</b> is called.  A DLL module
                    loaded at process initialization due to load-time dynamic linking has a
                    reference count of one.  This count is incremented if the same module is
                    loaded by a call to <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/>.
                </para>
                <para>
                    Before unmapping a library module, the system enables the DLL to detach from
                    the process by calling the DLL's <b>DllMain</b> function, if it has one, with
                    the DLL_PROCESS_DETACH value.  Doing so gives the DLL an opportunity to clean
                    up resources allocated on behalf of the current process.  After the
                    entry-point function returns, the library module is removed from the address
                    space of the current process.
                </para>
                <para>
                    It is not safe to call <b>FreeLibrary</b> from <b>DllMain</b>.  For more
                    information, see the Remarks section in <b>DllMain</b>.
                </para>
                <para>
                    Calling <b>FreeLibrary</b> does not affect other processes using the same
                    library module.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetDllDirectory(System.Int32,System.Text.StringBuilder)">
            <summary>
                The <b>GetDllDirectory</b> function retrieves the application-specific portion of
                the search path used to locate DLLs for the application.
            </summary>
            <param name="bufferLength">
                Size of the output buffer, in characters.
            </param>
            <param name="buffer">
                Pointer to a buffer that receives the application-specific portion of the search path.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the length of the string copied
                    to <i>buffer</i>, in characters, not including the terminating null character.
                    If the return value is greater than <i>bufferLength</i>, it specifies the size
                    of the buffer required for the path.
                </para>
                <para>
                    If the function fails, the return value is zero.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <seealso cref="M:Tao.Platform.Windows.Kernel.SetDllDirectory(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetModuleFileName(System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
                <para>
                    The <b>GetModuleFileName</b> function retrieves the fully qualified path for
                    the specified module.
                </para>
                <para>
                    To specify the process that contains the module, use the
                    <b>GetModuleFileNameEx</b> function.
                </para>
            </summary>
            <param name="module">
                Handle to the module whose path is being requested.  If this parameter is NULL,
                <b>GetModuleFileName</b> retrieves the path for the current module.
            </param>
            <param name="fileName">
                <para>
                    Pointer to a buffer that receives a null-terminated string that specifies the
                    fully-qualified path of the module.  If the length of the path exceeds the
                    size specified by the <i>size</i> parameter, the function succeeds and the
                    string is truncated to <i>size</i> characters and null terminated.
                </para>
                <para>
                    The path can have the prefix "\\?\", depending on how the module was loaded.
                </para>
            </param>
            <param name="size">
                Size of the <i>filename</i> buffer, in TCHARs.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the length of the string copied
                    to the buffer, in TCHARs.  If the buffer is too small to hold the module name,
                    the string is truncated to <i>size</i>, and the function returns <i>size</i>.
                </para>
                <para>
                    If the function fails, the return value is zero.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    If a DLL is loaded in two processes, its file name in one process may differ
                    in case from its file name in the other process.
                </para>
                <para>
                    For the ANSI version of the function, the number of TCHARs is the number of
                    bytes; for the Unicode version, it is the number of characters.
                </para>
                <para>
                    <b>Windows Me/98/95:</b>  This function retrieves long file names when an
                    application's version number is greater than or equal to 4.00 and the long
                    file name is available.  Otherwise, it returns only 8.3 format file names.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)">
            <summary>
                <para>
                    The <b>GetModuleHandle</b> function retrieves a module handle for the
                    specified module if the file has been mapped into the address space of the
                    calling process.
                </para>
                <para>
                    To avoid the race conditions described in the Remarks section, use the
                    <b>GetModuleHandleEx</b> function.
                </para>
            </summary>
            <param name="moduleName">
                <para>
                    Pointer to a null-terminated string that contains the name of the module
                    (either a .dll or .exe file).  If the file name extension is omitted, the
                    default library extension .dll is appended.  The file name string can include
                    a trailing point character (.) to indicate that the module name has no
                    extension.  The string does not have to specify a path.  When specifying a
                    path, be sure to use backslashes (\), not forward slashes (/).  The name is
                    compared (case independently) to the names of modules currently mapped into
                    the address space of the calling process.
                </para>
                <para>
                    If this parameter is NULL, <b>GetModuleHandle</b> returns a handle to the
                    file used to create the calling process.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is a handle to the specified module
                    (IntPtr).
                </para>
                <para>
                    If the function fails, the return value is NULL (IntPtr.Zero).  To get
                    extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The returned handle is not global or inheritable.  It cannot be duplicated
                    or used by another process.
                </para>
                <para>
                    The <b>GetModuleHandle</b> function returns a handle to a mapped module
                    without incrementing its reference count.  Therefore, use care when passing
                    the handle to the <see cref="M:Tao.Platform.Windows.Kernel.FreeLibrary(System.IntPtr)"/> function, because doing so can
                    cause a DLL module to be unmapped prematurely.
                </para>
                <para>
                    This function must be used carefully in a multithreaded application.  There
                    is no guarantee that the module handle remains valid between the time this
                    function returns the handle and the time it is used.  For example, a thread
                    retrieves a module handle, but before it uses the handle, a second thread
                    frees the module.  If the system loads another module, it could reuse the
                    module handle that was recently freed.  Therefore, first thread would have
                    a handle to a module different than the one intended.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.FreeLibrary(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetModuleFileName(System.IntPtr,System.Text.StringBuilder,System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetProcAddress(System.IntPtr,System.String)">
            <summary>
                The <b>GetProcAddress</b> function retrieves the address of an exported function
                or variable from the specified dynamic-link library (DLL).
            </summary>
            <param name="module">
                Handle to the DLL module that contains the function or variable.  The
                <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/> or <see cref="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)"/> function returns
                this handle.
            </param>
            <param name="processName">
                Pointer to a null-terminated string that specifies the function or variable name,
                or the function's ordinal value.  If this parameter is an ordinal value, it must
                be in the low-order word; the high-order word must be zero.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the address of the exported
                    function or variable.
                </para>
                <para>
                    If the function fails, the return value is NULL (IntPtr.Zero).  To get
                    extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The spelling and case of a function name pointed to by <i>processName</i> must
                    be identical to that in the EXPORTS statement of the source DLL's
                    module-definition (.def) file.  The exported names of functions may differ
                    from the names you use when calling these functions in your code.  This
                    difference is hidden by macros used in the SDK header files.
                </para>
                <para>
                    The <i>processName</i> parameter can identify the DLL function by specifying
                    an ordinal value associated with the function in the EXPORTS statement.
                    <b>GetProcAddress</b> verifies that the specified ordinal is in the range 1
                    through the highest ordinal value exported in the .def file.  The function
                    then uses the ordinal as an index to read the function's address from a
                    function table.  If the .def file does not number the functions consecutively
                    from 1 to N (where N is the number of exported functions), an error can occur
                    where <b>GetProcAddress</b> returns an invalid, non-NULL address, even though
                    there is no function with the specified ordinal.
                </para>
                <para>
                    In cases where the function may not exist, the function should be specified by
                    name rather than by ordinal value.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.FreeLibrary(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetModuleHandle(System.String)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetProcessWorkingSetSize(System.IntPtr,System.Int32@,System.Int32@)">
            <summary>
                The <b>GetProcessWorkingSetSize</b> function retrieves the minimum and maximum
                working set sizes of the specified process.
            </summary>
            <param name="process">
                Handle to the process whose working set sizes will be obtained.  The handle must
                have the PROCESS_QUERY_INFORMATION access right.
            </param>
            <param name="minimumWorkingSetSize">
                Pointer to a variable that receives the minimum working set size of the specified
                process, in bytes.  The virtual memory manager attempts to keep at least this much
                memory resident in the process whenever the process is active.
            </param>
            <param name="maximumWorkingSetSize">
                Pointer to a variable that receives the maximum working set size of the specified
                process, in bytes.  The virtual memory manager attempts to keep no more than this
                much memory resident in the process whenever the process is active when memory is
                in short supply.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                The "working set" of a process is the set of memory pages currently visible to
                the process in physical RAM memory.  These pages are resident and available for
                an application to use without triggering a page fault.  The minimum and maximum
                working set sizes affect the virtual memory paging behavior of a process.
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.SetProcessWorkingSetSize(System.IntPtr,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)">
            <summary>
                <para>
                    The <b>GetSystemDirectory</b> function retrieves the path of the system
                    directory.  The system directory contains system such files such as
                    dynamic-link libraries, drivers, and font files.
                </para>
                <para>
                    This function is provided primarily for compatibility.  Applications should
                    store code in the Program Files folder and persistent data in the Application
                    Data folder in the user's profile.
                </para>
            </summary>
            <param name="buffer">
                Pointer to the buffer to receive the null-terminated string containing the path.
                This path does not end with a backslash unless the system directory is the root
                directory.  For example, if the system directory is named Windows\System on drive
                C, the path of the system directory retrieved by this function is
                C:\Windows\System.
            </param>
            <param name="size">
                Maximum size of the buffer, in TCHARs.  This value should be set to at least
                MAX_PATH+1 to allow sufficient space for the path and the null terminator.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the length, in TCHARs, of the
                    string copied to the buffer, not including the terminating null character.  If
                    the length is greater than the size of the buffer, the return value is the
                    size of the buffer required to hold the path.
                </para>
                <para>
                    If the function fails, the return value is zero.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                Applications should not create files in the system directory.  If the user is
                running a shared version of the operating system, the application does not have
                write access to the system directory.
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetSystemInfo(Tao.Platform.Windows.Kernel.SYSTEM_INFO@)">
            <summary>
                <para>
                    The <b>GetSystemInfo</b> function returns information about the current
                    system.
                </para>
                <para>
                    To retrieve accurate information for a Win32-based application running on
                    WOW64, call the <b>GetNativeSystemInfo</b> function.
                </para>
            </summary>
            <param name="systemInfo">
                Pointer to a <see cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO"/> structure that receives the information.
            </param>
            <seealso cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetSystemWindowsDirectory(System.Text.StringBuilder,System.Int32)">
            <summary>
                The <b>GetSystemWindowsDirectory</b> function retrieves the path of the shared
                Windows directory on a multi-user system.
            </summary>
            <param name="buffer">
                Pointer to the buffer to receive a null-terminated string containing the path.
                This path does not end with a backslash unless the Windows directory is the root
                directory.  For example, if the Windows directory is named Windows on drive C,
                the path of the Windows directory retrieved by this function is C:\Windows.  If
                the system was installed in the root directory of drive C, the path retrieved
                is C:\.
            </param>
            <param name="size">
                Maximum size of the buffer specified by the <i>buffer</i> parameter, in TCHARs.
                This value should be set to at least MAX_PATH+1 to allow sufficient space for the
                path and the null-terminating character.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the length of the string copied
                    to the buffer, in TCHARs, not including the terminating null character.
                </para>
                <para>
                    If the length is greater than the size of the buffer, the return value is the
                    size of the buffer required to hold the path.
                </para>
                <para>
                    If the function fails, the return value is zero.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    On a system that is running Terminal Server, each user has a unique Windows
                    directory.  The system Windows directory is shared by all users, so it is the
                    directory where an application should store initialization and help files that
                    apply to all users.
                </para>
                <para>
                    With Terminal Services, the <b>GetSystemWindowsDirectory</b> function
                    retrieves the path of the system Windows directory, while the
                    <see cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/> function retrieves the path of a Windows
                    directory that is private for each user.  On a single-user system,
                    <b>GetSystemWindowsDirectory</b> is the same as
                    <see cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>.
                </para>
                <para>
                    <b>Windows NT 4.0 Terminal Server Edition:</b>  To retrieve the shared
                    Windows directory, call <see cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/> and trim the
                    "System32" element from the end of the returned path.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetTickCount">
            <summary>
                The <b>GetTickCount</b> function retrieves the number of milliseconds that have
                elapsed since the system was started.  It is limited to the resolution of the
                system timer.  To obtain the system timer resolution, use the
                <b>GetSystemTimeAdjustment</b> function.
            </summary>
            <returns>
                The return value is the number of milliseconds that have elapsed since the system
                was started.
            </returns>
            <remarks>
                <para>
                    The elapsed time is stored as a DWORD value.  Therefore, the time will wrap
                    around to zero if the system is run continuously for 49.7 days.
                </para>
                <para>
                    If you need a higher resolution timer, use a multimedia timer or a
                    high-resolution timer.
                </para>
                <para>
                    To obtain the time elapsed since the computer was started, retrieve the System
                    Up Time counter in the performance data in the registry key
                    HKEY_PERFORMANCE_DATA.  The value returned is an 8-byte value.
                </para>
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)">
            <summary>
                <para>
                    The <b>GetWindowsDirectory</b> function retrieves the path of the Windows
                    directory.  The Windows directory contains such files as applications,
                    initialization files, and help files.
                </para>
                <para>
                    This function is provided primarily for compatibility.  Applications should
                    store code in the Program Files folder and persistent data in the Application
                    Data folder in the user's profile.
                </para>
            </summary>
            <param name="buffer">
                Pointer to the buffer to receive the null-terminated string containing the path.
                This path does not end with a backslash unless the Windows directory is the root
                directory.  For example, if the Windows directory is named Windows on drive C, the
                path of the Windows directory retrieved by this function is C:\Windows.  If the
                system was installed in the root directory of drive C, the path retrieved is C:\.
            </param>
            <param name="size">
                Maximum size of the buffer specified by the <i>buffer</i> parameter, in TCHARs.
                This value should be set to MAX_PATH.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is the length of the string copied
                    to the buffer, in TCHARs, not including the terminating null character.
                </para>
                <para>
                    If the length is greater than the size of the buffer, the return value is the
                    size of the buffer required to hold the path.
                </para>
                <para>
                    If the function fails, the return value is zero.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The Windows directory is the directory where an application should store
                    initialization and help files. If the user is running a shared version of the
                    system, the Windows directory is guaranteed to be private for each user.
                </para>
                <para>
                    If an application creates other files that it wants to store on a per-user
                    basis, it should place them in the directory specified by the HOMEPATH
                    environment variable.  This directory will be different for each user, if so
                    specified by an administrator, through the User Manager administrative tool.
                    HOMEPATH always specifies either the user's home directory, which is
                    guaranteed to be private for each user, or a default directory (for example,
                    C:\USERS\DEFAULT) where the user will have all access.
                </para>
                <para>
                    <b>Terminal Services:</b>  If the application is running in a Terminal
                    Services environment, each user has a unique Windows directory.  If an
                    application that is not Terminal-Services-aware calls this function, it
                    retrieves the path of the Windows directory on the client, not the Windows
                    directory on the server.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetSystemWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.GlobalMemoryStatus(Tao.Platform.Windows.Kernel.MEMORYSTATUS@)">
            <summary>
                <para>
                    The <b>GlobalMemoryStatus</b> function obtains information about the system's
                    current usage of both physical and virtual memory.
                </para>
                <para>
                    To obtain information about the extended portion of the virtual address space,
                    or if your application may run on computers with more than 4 GB of main
                    memory, use the <b>GlobalMemoryStatusEx</b> function.
                </para>
            </summary>
            <param name="buffer">
                Pointer to a <see cref="T:Tao.Platform.Windows.Kernel.MEMORYSTATUS"/> structure.  The <b>GlobalMemoryStatus</b>
                function stores information about current memory availability into this structure.
            </param>
            <remarks>
                <para>
                    You can use the <b>GlobalMemoryStatus</b> function to determine how much
                    memory your application can allocate without severely impacting other
                    applications.
                </para>
                <para>
                    The information returned by the <b>GlobalMemoryStatus</b> function is
                    volatile.  There is no guarantee that two sequential calls to this function
                    will return the same information.
                </para>
                <para>
                    On computers with more than 4 GB of memory, the <b>GlobalMemoryStatus</b>
                    function can return incorrect information.  Windows 2000 and later report a
                    value of -1 to indicate an overflow.  Earlier versions of Windows NT report a
                    value that is the real amount of memory, modulo 4 GB.  For this reason, use
                    the <b>GlobalMemoryStatusEx</b> function instead.
                </para>
                <para>
                    On Intel x86 computers with more than 2 GB and less than 4 GB of memory, the
                    <b>GlobalMemoryStatus</b> function will always return 2 GB in the
                    <see cref="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.TotalPhys"/> member of the
                    <see cref="T:Tao.Platform.Windows.Kernel.MEMORYSTATUS"/> structure.  Similarly, if the total available
                    memory is between 2 and 4 GB, the <see cref="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.AvailPhys"/> member
                    of the <see cref="T:Tao.Platform.Windows.Kernel.MEMORYSTATUS"/> structure will be rounded down to 2 GB.  If
                    the executable is linked using the /LARGEADDRESSWARE linker option, then the
                    <b>GlobalMemoryStatus</b> function will return the correct amount of physical
                    memory in both members.
                </para>
            </remarks>
            <seealso cref="T:Tao.Platform.Windows.Kernel.MEMORYSTATUS"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.IsProcessorFeaturePresent(System.Int32)">
            <summary>
                The <b>IsProcessorFeaturePresent</b> function determines whether the specified
                processor feature is supported by the current computer.
            </summary>
            <param name="processorFeature">
                <para>
                    Processor feature to be tested.  This parameter can be one of the following
                    values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_3DNOW_INSTRUCTIONS_AVAILABLE"/></term>
                            <description>
                                The 3D-Now instruction set is available.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_COMPARE_EXCHANGE_DOUBLE"/></term>
                            <description>
                                The compare and exchange double operation is available (Pentium,
                                MIPS, and Alpha).
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_FLOATING_POINT_EMULATED"/></term>
                            <description>
                                <para>
                                    Floating-point operations are emulated using a software
                                    emulator.
                                </para>
                                <para>
                                    This function returns true if floating-point operations are
                                    emulated; otherwise, it returns false.
                                </para>
                                <para>
                                    <b>Windows NT 4.0:</b>  This function returns false if
                                    floating-point operations are emulated; otherwise, it returns
                                    true.  This behavior is a bug that is fixed in later versions.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_FLOATING_POINT_PRECISION_ERRATA"/></term>
                            <description>
                                <b>Pentium:</b>  In rare circumstances, a floating-point precision
                                error can occur.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_MMX_INSTRUCTIONS_AVAILABLE"/></term>
                            <description>
                                The MMX instruction set is available.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_PAE_ENABLED"/></term>
                            <description>
                                The processor is PAE-enabled.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_RDTSC_INSTRUCTION_AVAILABLE"/></term>
                            <description>
                                The RDTSC instruction is available.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_XMMI_INSTRUCTIONS_AVAILABLE"/></term>
                            <description>
                                The SSE instruction set is available.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.WinNt.PF_XMMI64_INSTRUCTIONS_AVAILABLE"/></term>
                            <description>
                                The SSE2 instruction set is available.
                            </description>
                        </item>
                    </list>
                </para>
            </param>
            <returns>
                <para>
                    If the feature is supported, the return value is true.
                </para>
                <para>
                    If the feature is not supported, the return value is false.
                </para>
            </returns>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)">
            <summary>
                The <b>LoadLibrary</b> function maps the specified executable module into the
                address space of the calling process.
            </summary>
            <param name="fileName">
                <para>
                    Pointer to a null-terminated string that names the executable module (either
                    a .dll or .exe file).  The name specified is the file name of the module and
                    is not related to the name stored in the library module itself, as specified
                    by the LIBRARY keyword in the module-definition (.def) file.
                </para>
                <para>
                    If the string specifies a path but the file does not exist in the specified
                    directory, the function fails.  When specifying a path, be sure to use
                    backslashes (\), not forward slashes (/).
                </para>
                <para>
                    If the string does not specify a path, the function uses a standard search
                    strategy to find the file.  See the Remarks for more information.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is a handle to the module (IntPtr).
                </para>
                <para>
                    If the function fails, the return value is NULL (IntPtr.Zero).  To get
                    extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
                <para>
                    <b>Windows Me/98/95:</b>  If you are using <b>LoadLibrary</b> to load a module
                    that contains a resource whose numeric identifier is greater than 0x7FFF,
                    <b>LoadLibrary</b> fails.  If you are attempting to load a 16-bit DLL directly
                    from 32-bit code, <b>LoadLibrary</b> fails.  If you are attempting to load a
                    DLL whose subsystem version is greater than 4.0, <b>LoadLibrary</b> fails.  If
                    your <b>DllMain</b> function tries to call the Unicode version of a function,
                    <b>LoadLibrary</b> fails.
                </para>
            </returns>
            <remarks>
                <para>
                    <b>LoadLibrary</b> can be used to map a DLL module and return a handle that
                    can be used in <see cref="M:Tao.Platform.Windows.Kernel.GetProcAddress(System.IntPtr,System.String)"/> to get the address of a DLL
                    function.  <b>LoadLibrary</b> can also be used to map other executable
                    modules.  For example, the function can specify an .exe file to get a
                    handle that can be used in <b>FindResource</b> or <b>LoadResource</b>.
                    However, do not use <b>LoadLibrary</b> to run an .exe file, use the
                    <b>CreateProcess</b> function.
                </para>
                <para>
                    If the module is a DLL not already mapped for the calling process, the system
                    calls the DLL's <b>DllMain</b> function with the DLL_PROCESS_ATTACH value.  If
                    the DLL's entry-point function does not return TRUE, <b>LoadLibrary</b> fails
                    and returns NULL.  (The system immediately calls your entry-point function
                    with DLL_PROCESS_DETACH and unloads the DLL.)
                </para>
                <para>
                    It is not safe to call <b>LoadLibrary</b> from <b>DllMain</b>.  For more
                    information, see the Remarks section in <b>DllMain</b>.
                </para>
                <para>
                    Module handles are not global or inheritable.  A call to <b>LoadLibrary</b> by
                    one process does not produce a handle that another process can use  for
                    example, in calling <see cref="M:Tao.Platform.Windows.Kernel.GetProcAddress(System.IntPtr,System.String)"/>.  The other process must
                    make its own call to <b>LoadLibrary</b> for the module before calling
                    <see cref="M:Tao.Platform.Windows.Kernel.GetProcAddress(System.IntPtr,System.String)"/>.
                </para>
                <para>
                    If no file name extension is specified in the <i>fileName</i> parameter, the
                    default library extension .dll is appended.  However, the file name string
                    can include a trailing point character (.) to indicate that the module name
                    has no extension.  When no path is specified, the function searches for loaded
                    modules whose base name matches the base name of the module to be loaded.  If
                    the name matches, the load succeeds.  Otherwise, the function searches for the
                    file in the following sequence:
                </para>
                <para>
                    <list type="number">
                        <item>
                            <description>
                                The directory from which the application loaded.
                            </description>
                        </item>
                        <item>
                            <description>
                                The current directory.
                            </description>
                        </item>
                        <item>
                            <description>
                                The system directory.  Use the <see cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/>
                                function to get the path of this directory.
                            </description>
                        </item>
                        <item>
                            <description>
                                <para>
                                    The 16-bit system directory.  There is no function that
                                    obtains the path of this directory, but it is searched.
                                </para>
                                <para>
                                    <b>Windows Me/98/95:</b>  This directory does not exist.
                                </para>
                            </description>
                        </item>
                        <item>
                            <description>
                                The Windows directory.  Use the <see cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
                                function to get the path of this directory.
                            </description>
                        </item>
                        <item>
                            <description>
                                The directories that are listed in the PATH environment variable.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    <b>Windows Server 2003, Windows XP SP1:</b>  The default value of
                    HKLM\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode is 1
                    (current directory is searched after the system and Windows directories).
                </para>
                <para>
                    <b>Windows XP:</b>  If
                    HKLM\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode is 1,
                    the current directory is searched after the system and Windows directories,
                    but before the directories in the PATH environment variable.  The default
                    value is 0 (current directory is searched before the system and Windows
                    directories).
                </para>
                <para>
                    The first directory searched is the one directory containing the image file
                    used to create the calling process (for more information, see the
                    <b>CreateProcess</b> function).  Doing this allows private dynamic-link
                    library (DLL) files associated with a process to be found without adding the
                    process's installed directory to the PATH environment variable.
                </para>
                <para>
                    The search path can be altered using the <see cref="M:Tao.Platform.Windows.Kernel.SetDllDirectory(System.String)"/>
                    function.  This solution is recommended instead of using
                    <b>SetCurrentDirectory</b> or hard-coding the full path to the DLL.
                </para>
                <para>
                    If a path is specified and there is a redirection file for the application,
                    the function searches for the module in the application's directory.  If the
                    module exists in the application's directory, the <b>LoadLibrary</b> function
                    ignores the specified path and loads the module from the application's
                    directory.  If the module does not exist in the application's directory,
                    <b>LoadLibrary</b> loads the module from the specified directory.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.FreeLibrary(System.IntPtr)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetProcAddress(System.IntPtr,System.String)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.SetDllDirectory(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)">
            <summary>
                The <b>QueryPerformanceCounter</b> function retrieves the current value of the
                high-resolution performance counter.
            </summary>
            <param name="performanceCount">
                Pointer to a variable that receives the current performance-counter value, in
                counts.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                On a multiprocessor machine, it should not matter which processor is called.
                However, you can get different results on different processors due to bugs in the
                BIOS or the HAL.  To specify processor affinity for a thread, use the
                <b>SetThreadAffinityMask</b> function.
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounterFast(System.Int64@)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceFrequency(System.Int64@)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounterFast(System.Int64@)">
            <summary>
                The <b>QueryPerformanceCounterFast</b> function retrieves the current value of the
                high-resolution performance counter.
            </summary>
            <param name="performanceCount">
                Pointer to a variable that receives the current performance-counter value, in
                counts.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.
                </para>
            </returns>
            <remarks>
                <para>
                    This version of <see cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)"/> is slightly faster.  It
                    does not set the last Windows error.  Use with care.
                </para>
                <para>
                    On a multiprocessor machine, it should not matter which processor is called.
                    However, you can get different results on different processors due to bugs in
                    the BIOS or the HAL.  To specify processor affinity for a thread, use the
                    <b>SetThreadAffinityMask</b> function.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceFrequency(System.Int64@)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.QueryPerformanceFrequency(System.Int64@)">
            <summary>
                The <b>QueryPerformanceFrequency</b> function retrieves the frequency of the
                high-resolution performance counter, if one exists.  The frequency cannot change
                while the system is running.
            </summary>
            <param name="frequency">
                Pointer to a variable that receives the current performance-counter frequency, in
                counts per second.  If the installed hardware does not support a high-resolution
                performance counter, this parameter can be zero.
            </param>
            <returns>
                <para>
                    If the installed hardware supports a high-resolution performance counter, the
                    return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.  For example, if
                    the installed hardware does not support a high-resolution performance counter,
                    the function fails.
                </para>
            </returns>
            <remarks>
                <b>Note</b>  The frequency of the high-resolution performance counter is not the
                processor speed.
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.SetDllDirectory(System.String)">
            <summary>
                The <b>SetDllDirectory</b> function modifies the search path used to locate DLLs
                for the application.
            </summary>
            <param name="pathName">
                Pointer to a null-terminated string that specifies the directories to be added to
                the search path, separated by semicolons.  If this parameter is NULL, the default
                search path is used.
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The <b>SetDllDirectory</b> function affects all subsequent calls to the
                    <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/> and <b>LoadLibraryEx</b> functions.  After calling
                    <b>SetDllDirectory</b>, the DLL search path is:
                </para>
                <para>
                    <list type="number">
                        <item>
                            <description>
                                The directory from which the application loaded.
                            </description>
                        </item>
                        <item>
                            <description>
                                The directory specified by the <i>pathName</i> parameter.
                            </description>
                        </item>
                        <item>
                            <description>
                                The system directory.  Use the <see cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/>
                                function to get the path of this directory.  The name of this
                                directory is System32.
                            </description>
                        </item>
                        <item>
                            <description>
                                The 16-bit system directory.  There is no function that obtains
                                the path of this directory, but it is searched.  The name of this
                                directory is System.
                            </description>
                        </item>
                        <item>
                            <description>
                                The Windows directory.  Use the <see cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
                                function to get the path of this directory.
                            </description>
                        </item>
                        <item>
                            <description>
                                The directories that are listed in the PATH environment variable.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    To revert to the default search path used by <see cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/> and
                    <b>LoadLibraryEx</b>, call <b>SetDllDirectory</b> with NULL.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetDllDirectory(System.Int32,System.Text.StringBuilder)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetSystemDirectory(System.Text.StringBuilder,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetWindowsDirectory(System.Text.StringBuilder,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.LoadLibrary(System.String)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Kernel.SetProcessWorkingSetSize(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                The <b>SetProcessWorkingSetSize</b> function sets the minimum and maximum working
                set sizes for the specified process.
            </summary>
            <param name="process">
                <para>
                    Handle to the process whose working set sizes is to be set.
                </para>
                <para>
                    The handle must have the PROCESS_SET_QUOTA access right.
                </para>
            </param>
            <param name="minimumWorkingSetSize">
                <para>
                    Minimum working set size for the process, in bytes.  The virtual memory
                    manager attempts to keep at least this much memory resident in the
                    process whenever the process is active.
                </para>
                <para>
                    If both <i>minimumWorkingSetSize</i> and <i>maximumWorkingSetSize</i> have the
                    value -1, the function temporarily trims the working set of the specified
                    process to zero.  This essentially swaps the process out of physical RAM
                    memory.
                </para>
            </param>
            <param name="maximumWorkingSetSize">
                <para>
                    Maximum working set size for the process, in bytes.  The virtual memory
                    manager attempts to keep no more than this much memory resident in the
                    process whenever the process is active and memory is in short supply.
                </para>
                <para>
                    If both <i>minimumWorkingSetSize</i> and <i>maximumWorkingSetSize</i> have the
                    value -1, the function temporarily trims the working set of the specified
                    process to zero.  This essentially swaps the process out of physical RAM
                    memory.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is true.
                </para>
                <para>
                    If the function fails, the return value is false.  To get extended error
                    information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The working set of a process is the set of memory pages currently visible to
                    the process in physical RAM memory.  These pages are resident and available
                    for an application to use without triggering a page fault.  The minimum and
                    maximum working set sizes affect the virtual memory paging behavior of a
                    process.
                </para>
                <para>
                    The working set of the specified process can be emptied by specifying the
                    value -1 for both the minimum and maximum working set sizes.
                </para>
                <para>
                    If the values of either <i>minimumWorkingSetSize</i> or
                    <i>maximumWorkingSetSize</i> are greater than the process' current working
                    set sizes, the specified process must have the SE_INC_BASE_PRIORITY_NAME
                    privilege.  Users in the Administrators and Power Users groups generally
                    have this privilege.
                </para>
                <para>
                    The operating system allocates working set sizes on a first-come,
                    first-served basis.  For example, if an application successfully sets 40
                    megabytes as its minimum working set size on a 64-megabyte system, and a
                    second application requests a 40-megabyte working set size, the operating
                    system denies the second application's request.
                </para>
                <para>
                    Using the <b>SetProcessWorkingSetSize</b> function to set an application's
                    minimum and maximum working set sizes does not guarantee that the requested
                    memory will be reserved, or that it will remain resident at all times.  When
                    the application is idle, or a low-memory situation causes a demand for memory,
                    the operating system can reduce the application's working set.  An application
                    can use the <b>VirtualLock</b> function to lock ranges of the application's
                    virtual address space in memory; however, that can potentially degrade the
                    performance of the system.
                </para>
                <para>
                    When you increase the working set size of an application, you are taking away
                    physical memory from the rest of the system.  This can degrade the performance
                    of other applications and the system as a whole.  It can also lead to failures
                    of operations that require physical memory to be present; for example,
                    creating processes, threads, and kernel pool.  Thus, you must use the
                    <b>SetProcessWorkingSetSize</b> function carefully.  You must always consider
                    the performance of the whole system when you are designing an application.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetProcessWorkingSetSize(System.IntPtr,System.Int32@,System.Int32@)"/>
        </member>
        <member name="T:Tao.Platform.Windows.Kernel.MEMORYSTATUS">
            <summary>
                <para>
                    The <b>MEMORYSTATUS</b> structure contains information about the current state
                    of both physical and virtual memory.
                </para>
                <para>
                    The <see cref="M:Tao.Platform.Windows.Kernel.GlobalMemoryStatus(Tao.Platform.Windows.Kernel.MEMORYSTATUS@)"/> function stores information in a
                    <b>MEMORYSTATUS</b> structure.
                </para>
            </summary>
            <remarks>
                <para>
                    <b>MEMORYSTATUS</b> reflects the state of memory at the time of the call.  It
                    reflects the size of the paging file at that time.  The operating system can
                    enlarge the paging file up to the maximum size set by the administrator.
                </para>
                <para>
                    On computers with more than 4 GB of memory, the <b>MEMORYSTATUS</b> structure
                    can return incorrect information.  Windows reports a value of -1 to indicate
                    an overflow, while Windows NT reports a value that is the real amount of
                    memory, modulo 4 GB.  If your application is at risk for this behavior, use
                    the <b>GlobalMemoryStatusEx</b> function instead of the
                    <see cref="M:Tao.Platform.Windows.Kernel.GlobalMemoryStatus(Tao.Platform.Windows.Kernel.MEMORYSTATUS@)"/> function.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GlobalMemoryStatus(Tao.Platform.Windows.Kernel.MEMORYSTATUS@)"/>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.Length">
            <summary>
                Size of the <b>MEMORYSTATUS</b> data structure, in bytes.  You do not need to
                set this member before calling the <see cref="M:Tao.Platform.Windows.Kernel.GlobalMemoryStatus(Tao.Platform.Windows.Kernel.MEMORYSTATUS@)"/> function;
                the function sets it.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.MemoryLoad">
            <summary>
                <para>
                    Approximate percentage of total physical memory that is in use.
                </para>
                <para>
                    <b>Windows NT:</b>  Percentage of approximately the last 1000 pages of
                    physical memory that is in use.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.TotalPhys">
            <summary>
                Total size of physical memory, in bytes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.AvailPhys">
            <summary>
                Size of physical memory available, in bytes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.TotalPageFile">
            <summary>
                Size of the committed memory limit, in bytes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.AvailPageFile">
            <summary>
                Size of available memory to commit, in bytes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.TotalVirtual">
            <summary>
                Total size of the user mode portion of the virtual address space of the
                calling process, in bytes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.MEMORYSTATUS.AvailVirtual">
            <summary>
                Size of unreserved and uncommitted memory in the user mode portion of the
                virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO">
            <summary>
                The <b>SYSTEM_INFO</b> structure contains information about the current computer
                system.  This includes the architecture and type of the processor, the number of
                processors in the system, the page size, and other such information.
            </summary>
            <seealso cref="M:Tao.Platform.Windows.Kernel.GetSystemInfo(Tao.Platform.Windows.Kernel.SYSTEM_INFO@)"/>
            <seealso cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION"/>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.SystemInfoUnion">
            <summary>
                Union for the OemId, ProcessorArchitecture, and Reserved fields of the
                SYSTEM_INFO structure.  See <see cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION"/>.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.PageSize">
            <summary>
                Page size and the granularity of page protection and commitment.  This is the
                page size used by the <b>VirtualAlloc</b> function.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.MinimumApplicationAddress">
            <summary>
                Pointer to the lowest memory address accessible to applications and
                dynamic-link libraries (DLLs).
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.MaximumApplicationAddress">
            <summary>
                Pointer to the highest memory address accessible to applications and DLLs.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.ActiveProcessorMask">
            <summary>
                Mask representing the set of processors configured into the system.  Bit 0 is
                processor 0; bit 31 is processor 31.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.NumberOfProcessors">
            <summary>
                Number of processors in the system.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.ProcessorType">
            <summary>
                <para>
                    An obsolete member that is retained for compatibility with Windows NT 3.5
                    and earlier.  Use the <i>SystemInfoUnion.ProcessorArchitecture</i>,
                    <i>ProcessorLevel</i>, and <i>ProcessorRevision</i> members to determine
                    the type of processor.
                </para>
                <para>
                    <b>Windows Me/98/95:</b>  Specifies the type of processor in the system.
                    This member is one of the following values:
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_386"/>
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_486"/>
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_INTEL_PENTIUM"/>
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.AllocationGranularity">
            <summary>
                Granularity with which virtual memory is allocated.  For example, a
                <b>VirtualAlloc</b> request to allocate 1 byte will reserve an address space
                of <i>AllocationGranularity</i> bytes.  This value was hard coded as 64K in
                the past, but other hardware architectures may require different values.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.ProcessorLevel">
            <summary>
                <para>
                    System's architecture-dependent processor level.  It should be used only
                    for display purposes.  To determine the feature set of a processor, use
                    the <see cref="M:Tao.Platform.Windows.Kernel.IsProcessorFeaturePresent(System.Int32)"/> function.
                </para>
                <para>
                    If <i>SystemInfoUnion.ProcessorArchitecture</i> is
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_INTEL"/>, <i>ProcessorLevel</i>
                    is defined by the CPU vendor.
                </para>
                <para>
                    If <i>SystemInfoUnion.ProcessorArchitecture</i> is
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_IA64"/>, <i>ProcessorLevel</i> is
                    set to 1.
                </para>
                <para>
                    If <i>SystemInfoUnion.ProcessorArchitecture</i> is
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_MIPS"/>, <i>ProcessorLevel</i> is
                    of the form 00xx, where xx is an 8-bit implementation number (bits 8-15 of
                    the PRId register).  The member can be the following value:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>0004</term>
                            <description>MIPS R4000</description>
                        </item>
                    </list>
                </para>
                <para>
                    If <i>SystemInfoUnion.ProcessorArchitecture</i> is
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_ALPHA"/>, <i>ProcessorLevel</i>
                    is of the form xxxx, where xxxx is a 16-bit processor version number (the
                    low-order 16 bits of a version number from the firmware).  The member can
                    be one of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>21064</term>
                            <description>Alpha 21064</description>
                        </item>
                        <item>
                            <term>21066</term>
                            <description>Alpha 21066</description>
                        </item>
                        <item>
                            <term>21164</term>
                            <description>Alpha 21164</description>
                        </item>
                    </list>
                </para>
                <para>
                    If <i>SystemInfoUnion.ProcessorArchitecture</i> is
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_PPC"/>, <i>ProcessorLevel</i> is
                    of the form xxxx, where xxxx is a 16-bit processor version number (the
                    high-order 16 bits of the Processor Version Register).  The member can be
                    one of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>1</term>
                            <description>PPC 601</description>
                        </item>
                        <item>
                            <term>3</term>
                            <description>PPC 603</description>
                        </item>
                        <item>
                            <term>4</term>
                            <description>PPC 604</description>
                        </item>
                        <item>
                            <term>6</term>
                            <description>PPC 603+</description>
                        </item>
                        <item>
                            <term>9</term>
                            <description>PPC 604+</description>
                        </item>
                        <item>
                            <term>20</term>
                            <description>PPC 620</description>
                        </item>
                    </list>
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO.ProcessorRevision">
            <summary>
                <para>
                    Architecture-dependent processor revision.  The following table shows how
                    the revision value is assembled for each type of processor architecture:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Processor</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>Intel 80386 or 80486</term>
                            <description>
                                <para>
                                    A value of the form xxyz.
                                </para>
                                <para>
                                    If xx is equal to 0xFF, y - 0xA is the model number, and
                                    z is the stepping identifier.  For example, an Intel
                                    80486-D0 system returns 0xFFD0.
                                </para>
                                <para>
                                    If xx is not equal to 0xFF, xx + 'A' is the stepping
                                    letter and yz is the minor stepping.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term>Intel Pentium, Cyrix, or NextGen 586</term>
                            <description>
                                <para>
                                    A value of the form xxyy, where xx is the model number and
                                    yy is the stepping.  Display this value of 0x0201 as
                                    follows:
                                </para>
                                <para>
                                    Model xx, Stepping yy.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term>MIPS</term>
                            <description>
                                A value of the form 00xx, where xx is the 8-bit revision
                                number of the processor (the low-order 8 bits of the
                                PRId register).
                            </description>
                        </item>
                        <item>
                            <term>ALPHA</term>
                            <description>
                                <para>
                                    A value of the form xxyy, where xxyy is the low-order 16
                                    bits of the processor revision number from the firmware.
                                    Display this value as follows:
                                </para>
                                <para>
                                    Model A+xx, Pass yy.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term>PPC</term>
                            <description>
                                <para>
                                    A value of the form xxyy, where xxyy is the low-order 16
                                    bits of the processor version register.  Display this
                                    value as follows:
                                </para>
                                <para>
                                    xx.yy.
                                </para>
                            </description>
                        </item>
                    </list>
                </para>
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION">
            <summary>
                Union for the OemId, ProcessorArchitecture, and Reserved fields of the
                <see cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO"/> structure.
            </summary>
            <seealso cref="T:Tao.Platform.Windows.Kernel.SYSTEM_INFO"/>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION.OemId">
            <summary>
                <para>
                    An obsolete member that is retained for compatibility with Windows NT 3.5
                    and earlier.  New applications should use the <i>ProcessorArchitecture</i>
                    branch of the union.
                </para>
                <para>
                    <b>Windows Me/98/95:</b>  The system always sets this member to zero, the
                    value defined for <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_INTEL"/>.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION.ProcessorArchitecture">
            <summary>
                <para>
                    System's processor architecture.  This value can be one of the following
                    values:
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_UNKNOWN"/>
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_INTEL"/>
                </para>
                <para>
                    <b>Windows NT 3.51:</b>  <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_MIPS"/>
                </para>
                <para>
                    <b>Windows NT 4.0 and earlier:</b>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_ALPHA"/>
                </para>
                <para>
                    <b>Windows NT 4.0 and earlier:</b>
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_PPC"/>
                </para>
                <para>
                    <b>64-bit Windows:</b>  <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_IA64"/>,
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_IA32_ON_WIN64"/>,
                    <see cref="F:Tao.Platform.Windows.WinNt.PROCESSOR_ARCHITECTURE_AMD64"/>
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Kernel.SYSTEM_INFO_UNION.Reserved">
            <summary>
                Reserved for future use.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.IlasmAttribute">
            <summary>
                Injects supplied MSIL into the method's body.
            </summary>
            <remarks>
                This is a hack as the C# compiler does not allow inline MSIL.  This is extracted and
                the appropriate MSIL injected by the PostProcessTao utility.
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.IlasmAttribute.#ctor(System.String)">
            <summary>
                Injects the supplied MSIL into the tagged method's body.
            </summary>
            <param name="msil">
                The MSIL to inject.
            </param>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.GetDelegate(System.String,System.Type)">
            <summary>
            Creates a System.Delegate that can be used to call an OpenGL function, core or extension.
            </summary>
            <param name="name">The name of the OpenGL function (eg. "glNewList")</param>
            <param name="signature">The signature of the OpenGL function.</param>
            <returns>
            A System.Delegate that can be used to call this OpenGL function, or null if the specified
            function name did not correspond to an OpenGL function.
            </returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.ReloadFunctions">
            <summary>
            Loads all OpenGL functions (core and extensions).
            </summary>
            <remarks>
            <para>
            This function will be automatically called the first time you use any opengl function. There is 
            </para>
            <para>
            Call this function manually whenever you need to update OpenGL entry points.
            This need may arise if you change the pixelformat/visual, or in case you cannot
            (or do not want) to use the automatic initialization of the GL class.
            </para>
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.Load(System.String)">
            <summary>
            Tries to reload the given OpenGL function (core or extension).
            </summary>
            <param name="function">The name of the OpenGL function (i.e. glShaderSource)</param>
            <returns>True if the function was found and reloaded, false otherwise.</returns>
            <remarks>
            <para>
            Use this function if you require greater granularity when loading OpenGL entry points.
            </para>
            <para>
            While the automatic initialisation will load all OpenGL entry points, in some cases
            the initialisation can take place before an OpenGL Context has been established.
            In this case, use this function to load the entry points for the OpenGL functions
            you will need, or use ReloadFunctions() to load all available entry points.
            </para>
            <para>
            This function returns true if the given OpenGL function is supported, false otherwise.
            </para>
            <para>
            To query for supported extensions use the IsExtensionSupported() function instead.
            </para>
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.GetExtensionDelegate(System.String,System.Type)">
            <summary>
            Creates a System.Delegate that can be used to call a dynamically exported OpenGL function.
            </summary>
            <param name="name">The name of the OpenGL function (eg. "glNewList")</param>
            <param name="signature">The signature of the OpenGL function.</param>
            <returns>
            A System.Delegate that can be used to call this OpenGL function or null
            if the function is not available in the current OpenGL context.
            </returns>
        </member>
        <member name="M:Tao.Platform.Windows.Wgl.IsExtensionSupported(System.String)">
            <summary>
            Determines whether the specified OpenGL extension category is available in
            the current OpenGL context. Equivalent to IsExtensionSupported(name, true)
            </summary>
            <param name="name">The string for the OpenGL extension category (eg. "GL_ARB_multitexture")</param>
            <returns>True if the specified extension is available, false otherwise.</returns>
        </member>
        <member name="T:Tao.Platform.Windows.Wgl.Imports">
            <summary>
            Contains DllImports for the core OpenGL functions.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Wgl.Imports.FunctionMap">
            <summary>
             Build a string->MethodInfo map to speed up extension loading.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Winmm">
            <summary>
                Windows Multimedia binding for .NET, implementing Windows-specific multimedia
                functionality.
            </summary>
            <remarks>
                Binds functions and definitions in winmm.dll.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.WINMM_NATIVE_LIBRARY">
            <summary>
                Specifies Winmm's native library archive.
            </summary>
            <remarks>
                Specifies winmm.dll for Windows.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.StdCall"/>.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_SYNC">
            <summary>
                Synchronous playback of a sound event.  <b>PlaySound</b> returns after the sound
                event completes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_ASYNC">
            <summary>
                The sound is played asynchronously and <b>PlaySound</b> returns immediately after
                beginning the sound.  To terminate an asynchronously played waveform sound, call
                <b>PlaySound</b> with <i>sound</i> set to NULL.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_NODEFAULT">
            <summary>
                No default sound event is used.  If the sound cannot be found, <b>PlaySound</b>
                returns silently without playing the default sound.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_MEMORY">
            <summary>
                A sound event's file is loaded in RAM.  The parameter specified by <i>sound</i>
                must point to an image of a sound in memory.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_LOOP">
            <summary>
                The sound plays repeatedly until <b>PlaySound</b> is called again with the
                <i>sound</i> parameter set to NULL.  You must also specify the
                <see cref="F:Tao.Platform.Windows.Winmm.SND_ASYNC"/> flag to indicate an asynchronous sound event.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_NOSTOP">
            <summary>
                <para>
                    The specified sound event will yield to another sound event that is already
                    playing.  If a sound cannot be played because the resource needed to
                    generate that sound is busy playing another sound, the function immediately
                    returns FALSE without playing the requested sound.
                </para>
                <para>
                    If this flag is not specified, <b>PlaySound</b> attempts to stop the currently
                    playing sound so that the device can be used to play the new sound.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_NOWAIT">
            <summary>
                If the driver is busy, return immediately without playing the sound.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_ALIAS">
            <summary>
                The <i>sound</i> parameter is a system-event alias in the registry or the WIN.INI
                file.  Do not use with either <see cref="F:Tao.Platform.Windows.Winmm.SND_FILENAME"/> or
                <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/>.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_ALIAS_ID">
            <summary>
                The <i>sound</i> parameter is a predefined sound identifier.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_FILENAME">
            <summary>
                The <i>sound</i> parameter is a filename.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_RESOURCE">
            <summary>
                The <i>sound</i> parameter is a resource identifier; <i>mod</i> must identify the
                instance that contains the resource.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_PURGE">
            <summary>
                <para>
                    Sounds are to be stopped for the calling task.  If <i>sound</i> is not
                    NULL, all instances of the specified sound are stopped.  If <i>sound</i> is
                    NULL, all sounds that are playing on behalf of the calling task are stopped.
                </para>
                <para>
                    You must also specify the instance handle to stop <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/>
                    events.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.SND_APPLICATION">
            <summary>
                The sound is played using an application-specific association.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.TIMERR_BASE">
            <summary>
                Timer base identifier.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.TIMERR_NOERROR">
            <summary>
                Successful.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.TIMERR_NOCANDO">
            <summary>
                Resolution specified is out of range.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_BUTTON1">
            <summary>
                First joystick button is pressed.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_BUTTON2">
            <summary>
                Second joystick button is pressed.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_BUTTON3">
            <summary>
                Third joystick button is pressed.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_BUTTON4">
            <summary>
                Four joystick button is pressed.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS_HASZ">
            <summary>
                Joystick has z-coordinate information.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS_HASR">
            <summary>
                Joystick has rudder (fourth axis) information.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS_HASU">
            <summary>
                Joystick has u-coordinate (fifth axis) information.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS_HASV">
            <summary>
                Joystick has v-coordinate (sixth axis) information.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS_HASPOV">
            <summary>
                Joystick has point-of-view information.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS_POV4DIR">
            <summary>
                Joystick point-of-view supports discrete values (centered, forward, backward, left, and right).
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS_POVCTS">
            <summary>
                Joystick point-of-view supports continuous degree bearings.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNX">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNY">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNZ">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNR">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNU">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNV">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNPOV">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNBUTTONS">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNRAWDATA">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNPOVCTS">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNCENTERED">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_USEDEADZONE">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_RETURNALL">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READALWAYS">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READXYONLY">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READ3">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READ4">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READXONLY">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READYONLY">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READ5">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READ6">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READZONLY">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READRONLY">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READUONLY">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_CAL_READVONLY">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_POVCENTERED">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_POVFORWARD">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_POVRIGHT">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_POVBACKWARD">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOY_POVLEFT">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_BASE">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_NOERROR">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_ERROR">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_BADDEVICEID">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_NOTENABLED">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_ALLOCATED">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_INVALHANDLE">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_NODRIVER">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_NOMEM">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_NOTSUPPORTED">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_BADERRNUM">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_INVALFLAG">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_INVALPARAM">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MMSYSERR_LASTERROR">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYERR_NOERROR">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYERR_PARMS">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYERR_NOCANDO">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYERR_UNPLUGGED">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYSTICKID1">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYSTICKID2">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MM_JOY1MOVE">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MM_JOY2MOVE">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MM_JOY1ZMOVE">
            <summary></summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.MM_JOY2ZMOVE">
            <summary></summary>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.PlaySound(System.String,System.IntPtr,System.Int32)">
            <summary>
                The <b>PlaySound</b> function plays a sound specified by the given filename,
                resource, or system event.  (A system event may be associated with a sound in the
                registry or in the WIN.INI file.)
            </summary>
            <param name="sound">
                <para>
                    A string that specifies the sound to play.  If this parameter is NULL, any
                    currently playing waveform sound is stopped.  To stop a non-waveform sound,
                    specify <see cref="F:Tao.Platform.Windows.Winmm.SND_PURGE"/> in the <i>soundFlags</i> parameter.
                </para>
                <para>
                    Three flags in <i>soundFlags</i> (<see cref="F:Tao.Platform.Windows.Winmm.SND_ALIAS"/>,
                    <see cref="F:Tao.Platform.Windows.Winmm.SND_FILENAME"/>, and <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/>) determine
                    whether the name is interpreted as an alias for a system event, a filename, or
                    a resource identifier.  If none of these flags are specified, <b>PlaySound</b>
                    searches the registry or the WIN.INI file for an association with the
                    specified sound name.  If an association is found, the sound event is played.
                    If no association is found in the registry, the name is interpreted as a
                    filename.
                </para>
            </param>
            <param name="mod">
                Handle to the executable file that contains the resource to be loaded.  This
                parameter must be NULL unless <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/> is specified in
                <i>soundFlags</i>.
            </param>
            <param name="soundFlags">
                <para>
                    Flags for playing the sound.  The following values are defined:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_APPLICATION"/></term>
                            <description>
                                The sound is played using an application-specific association.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_ALIAS"/></term>
                            <description>
                                The <i>sound</i> parameter is a system-event alias in the registry
                                or the WIN.INI file.  Do not use with either
                                <see cref="F:Tao.Platform.Windows.Winmm.SND_FILENAME"/> or <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/>.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_ALIAS_ID"/></term>
                            <description>
                                The <i>sound</i> parameter is a predefined sound identifier.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_ASYNC"/></term>
                            <description>
                                The sound is played asynchronously and <b>PlaySound</b> returns
                                immediately after beginning the sound.  To terminate an
                                asynchronously played waveform sound, call <b>PlaySound</b> with
                                <i>sound</i> set to NULL.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_FILENAME"/></term>
                            <description>
                                The <i>sound</i> parameter is a filename.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_LOOP"/></term>
                            <description>
                                The sound plays repeatedly until <b>PlaySound</b> is called again
                                with the <i>sound</i> parameter set to NULL.  You must also
                                specify the <see cref="F:Tao.Platform.Windows.Winmm.SND_ASYNC"/> flag to indicate an
                                asynchronous sound event.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_MEMORY"/></term>
                            <description>
                                A sound event's file is loaded in RAM.  The parameter specified by
                                <i>sound</i> must point to an image of a sound in memory.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_NODEFAULT"/></term>
                            <description>
                                No default sound event is used.  If the sound cannot be found,
                                <b>PlaySound</b> returns silently without playing the default
                                sound.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_NOSTOP"/></term>
                            <description>
                                <para>
                                    The specified sound event will yield to another sound event
                                    that is already playing.  If a sound cannot be played because
                                    the resource needed to generate that sound is busy playing
                                    another sound, the function immediately returns FALSE without
                                    playing the requested sound.
                                </para>
                                <para>
                                    If this flag is not specified, <b>PlaySound</b> attempts to
                                    stop the currently playing sound so that the device can be
                                    used to play the new sound.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_NOWAIT"/></term>
                            <description>
                                If the driver is busy, return immediately without playing the
                                sound.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_PURGE"/></term>
                            <description>
                                <para>
                                    Sounds are to be stopped for the calling task.  If
                                    <i>sound</i> is not NULL, all instances of the specified sound
                                    are stopped.  If <i>sound</i> is NULL, all sounds that are
                                    playing on behalf of the calling task are stopped.
                                </para>
                                <para>
                                    You must also specify the instance handle to stop
                                    <see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/> events.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_RESOURCE"/></term>
                            <description>
                                The <i>sound</i> parameter is a resource identifier; <i>mod</i>
                                must identify the instance that contains the resource.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Winmm.SND_SYNC"/></term>
                            <description>
                                Synchronous playback of a sound event.  <b>PlaySound</b> returns
                                after the sound event completes.
                            </description>
                        </item>
                    </list>
                </para>
            </param>
            <returns>
                Returns TRUE if successful or FALSE otherwise.
            </returns>
            <remarks>
                <para>
                    The sound specified by <i>sound</i> must fit into available physical memory
                    and be playable by an installed waveform-audio device driver.
                    <b>PlaySound</b> searches the following directories for sound files: the
                    current directory; the Windows directory; the Windows system directory;
                    directories listed in the PATH environment variable; and the list of
                    directories mapped in a network.  For more information about the directory
                    search order, see the documentation for the <b>OpenFile</b> function.
                </para>
                <para>
                    If it cannot find the specified sound, <b>PlaySound</b> uses the default
                    system event sound entry instead.  If the function can find neither the
                    system default entry nor the default sound, it makes no sound and returns
                    FALSE.
                </para>
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)">
            <summary>
                The <b>timeBeginPeriod</b> function sets the minimum timer resolution for an
                application or device driver.
            </summary>
            <param name="period">
                Minimum timer resolution, in milliseconds, for the application or device driver.
            </param>
            <returns>
                Returns <see cref="F:Tao.Platform.Windows.Winmm.TIMERR_NOERROR"/> if successful or
                <see cref="F:Tao.Platform.Windows.Winmm.TIMERR_NOCANDO"/> if the resolution specified in <i>period</i> is out
                of range.
            </returns>
            <remarks>
                <para>
                    Call this function immediately before using timer services, and call the
                    <see cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/> function immediately after you are finished
                    using the timer services.
                </para>
                <para>
                    You must match each call to <b>timeBeginPeriod</b> with a call to
                    <see cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>, specifying the same minimum resolution in both
                    calls.  An application can make multiple <b>timeBeginPeriod</b> calls as long
                    as each call is matched with a call to <see cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)">
            <summary>
                The <b>timeEndPeriod</b> function clears a previously set minimum timer
                resolution.
            </summary>
            <param name="period">
                Minimum timer resolution specified in the previous call to the
                <see cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/> function.
            </param>
            <returns>
                Returns <see cref="F:Tao.Platform.Windows.Winmm.TIMERR_NOERROR"/> if successful or
                <see cref="F:Tao.Platform.Windows.Winmm.TIMERR_NOCANDO"/> if the resolution specified in <i>period</i> is out
                of range
            </returns>
            <remarks>
                <para>
                    Call this function immediately after you are finished using timer services.
                </para>
                <para>
                    You must match each call to <see cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/> with a call to
                    <b>timeEndPeriod</b>, specifying the same minimum resolution in both calls.
                    An application can make multiple <see cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/> calls as long
                    as each call is matched with a call to <b>timeEndPeriod</b>.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.timeGetTime">
            <summary>
                The <b>timeGetTime</b> function retrieves the system time, in milliseconds.
                The system time is the time elapsed since Windows was started.
            </summary>
            <returns>
                Returns the system time, in milliseconds.
            </returns>
            <remarks>
                <para>
                    The only difference between this function and the <b>timeGetSystemTime</b>
                    function is that <b>timeGetSystemTime</b> uses the <b>MMTIME</b> structure to
                    return the system time.  The <b>timeGetTime</b> function has less overhead
                    than <b>timeGetSystemTime</b>.
                </para>
                <para>
                    Note that the value returned by the <b>timeGetTime</b> function is a DWORD
                    value.  The return value wraps around to 0 every 2^32 milliseconds, which is
                    about 49.71 days.  This can cause problems in code that directly uses the
                    <b>timeGetTime</b> return value in computations, particularly where the value
                    is used to control code execution.  You should always use the difference
                    between two <b>timeGetTime</b> return values in computations.
                </para>
                <para>
                    <b>Windows NT/2000:</b> The default precision of the <b>timeGetTime</b>
                    function can be five milliseconds or more, depending on the machine.  You
                    can use the <see cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/> and <see cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>
                    functions to increase the precision of <b>timeGetTime</b>.  If you do so, the
                    minimum difference between successive values returned by <b>timeGetTime</b>
                    can be as large as the minimum period value set using
                    <see cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/> and <see cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>.  Use the
                    <see cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)"/> and
                    <see cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceFrequency(System.Int64@)"/> functions to measure short
                    time intervals at a high resolution.
                </para>
                <para>
                    <b>Windows 95:</b> The default precision of the <b>timeGetTime</b> function is
                    1 millisecond.  In other words, the <b>timeGetTime</b> function can return
                    successive values that differ by just 1 millisecond.  This is true no matter
                    what calls have been made to the <b>timeBeginPeriod</b> and
                    <b>timeEndPeriod</b> functions.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceCounter(System.Int64@)"/>
            <seealso cref="M:Tao.Platform.Windows.Kernel.QueryPerformanceFrequency(System.Int64@)"/>
            <seealso cref="M:Tao.Platform.Windows.Winmm.timeBeginPeriod(System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.Winmm.timeEndPeriod(System.Int32)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.joyConfigChanged(System.Int64)">
            <summary>
                The joyConfigChanged function informs the joystick driver that the configuration has changed and should be reloaded from the registry.
            </summary>
            <param name="dwFlags">
                Reserved for future use. Must equal zero.
            </param>
            <returns>
                Returns JOYERR_NOERROR if successful. Returns JOYERR_PARMS if the parameter is non-zero.
            </returns>
            <remarks>
                <para>
                    This function causes a window message to be sent to all top-level windows. This message may be defined by applications that need to respond to changes in joystick calibration by using RegisterWindowMessage with the following message ID:
                </para>
                <code>
                    #define JOY_CONFIGCHANGED_MSGSTRING     "MSJSTICK_VJOYD_MSGSTR"
                </code>
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.joyGetDevCaps(System.IntPtr,Tao.Platform.Windows.Winmm.JOYCAPS@,System.Int32)">
            <summary>
                The joyGetDevCaps function queries a joystick to determine its capabilities.
            </summary>
            <param name="uJoyID">
                Identifier of the joystick to be queried. Valid values for uJoyID range from -1 to 15. A value of -1 enables retrieval of the szRegKey member of the JOYCAPS structure whether a device is present or not. For Windows NT 4.0, valid values are limited to zero (JOYSTICKID1) and JOYSTICKID2.
            </param>
            <param name="pjc">
                Pointer to a <see cref="T:Tao.Platform.Windows.Winmm.JOYCAPS"/> structure to contain the capabilities of the joystick.
            </param>
            <param name="cbjc"> 
                Size, in bytes, of the JOYCAPS structure.
            </param>
            <returns>
                <para>
                    Returns JOYERR_NOERROR if successful or one of the following error values:
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_NODRIVER"/> - The joystick driver is not present. Windows NT/2000/XP: The specified joystick identifier is invalid.
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_INVALPARAM"/> - An invalid parameter was passed. Windows 95/98/Me: The specified joystick identifier is invalid.
                </para>
            </returns>
            <remarks>
                <para>
                    Use the <see cref="M:Tao.Platform.Windows.Winmm.joyGetNumDevs"/> function to determine the number of joystick devices supported by the driver.
                </para>
                <para>
                    Windows NT/2000/XP: This method fails when passed an invalid value for the cbjc parameter.
                    Windows 95/98/Me: This method succeeds when passed an invalid value for the cbjc parameter.
                </para>
            </remarks>
            <seealso cref="T:Tao.Platform.Windows.Winmm.JOYCAPS"/>
            <seealso cref="M:Tao.Platform.Windows.Winmm.joyGetNumDevs"/>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.joyGetNumDevs">
            <summary>
                The joyGetNumDevs function queries the joystick driver for the number of joysticks it supports.
            </summary>
            <returns>
                The joyGetNumDevs function returns the number of joysticks supported by the current driver or zero if no driver is installed.
            </returns>
            <remarks>
                <para>
                    Use the <see cref="M:Tao.Platform.Windows.Winmm.joyGetPos(System.Int32,Tao.Platform.Windows.Winmm.JOYINFO@)"/> function to determine whether a given joystick is physically attached to the system. If the specified joystick is not connected, joyGetPos returns a <see cref="F:Tao.Platform.Windows.Winmm.JOYERR_UNPLUGGED"/> error value.
                </para>
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.joyGetPos(System.Int32,Tao.Platform.Windows.Winmm.JOYINFO@)">
            <summary>
                The joyGetPos function queries a joystick for its position and button status.
            </summary>
            <param name="uJoyID">
                Identifier of the joystick to be queried. Valid values for uJoyID range from zero (<see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/>) to 15, except for Windows NT 4.0. For Windows NT 4.0, valid values are limited to <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/> and <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID2"/>.
            </param>
            <param name="pji">
                Pointer to a <see cref="T:Tao.Platform.Windows.Winmm.JOYINFO"/> structure that contains the position and button status of the joystick.
            </param>
            <returns>
                Returns <see cref="F:Tao.Platform.Windows.Winmm.JOYERR_NOERROR"/> if successful or one of the following error values.
                <para>
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_NODRIVER"/> - The joystick driver is not present.
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_INVALPARAM"/> - An invalid parameter was passed.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOYERR_UNPLUGGED"/> - The specified joystick is not connected to the system.
                </para>
            </returns>
            <remarks>
                For devices that have four to six axes of movement, a point-of-view control, or more than four buttons, use the <see cref="M:Tao.Platform.Windows.Winmm.joyGetPosEx(System.Int32,Tao.Platform.Windows.Winmm.JOYINFOEX@)"/> function.
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.joyGetPosEx(System.Int32,Tao.Platform.Windows.Winmm.JOYINFOEX@)">
            <summary>
                The joyGetPosEx function queries a joystick for its position and button status.
            </summary>
            <param name="uJoyID">
                Identifier of the joystick to be queried. Valid values for uJoyID range from zero (<see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/>) to 15, except for Windows NT 4.0. For Windows NT 4.0, valid values are limited to <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/> and <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID2"/>.
            </param>
            <param name="pji">
                Pointer to a <see cref="T:Tao.Platform.Windows.Winmm.JOYINFOEX"/> structure that contains extended position information and button status of the joystick. You must set the dwSize and dwFlags members or joyGetPosEx will fail. The information returned from joyGetPosEx depends on the flags you specify in dwFlags.
            </param>
            <returns>
                Returns JOYERR_NOERROR if successful or one of the following error values.
                <para>
                    Returns JOYERR_NOERROR if successful or one of the following error values.
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_NODRIVER"/> - The joystick driver is not present.
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_INVALPARAM"/> - An invalid parameter was passed. Windows 95/98/Me: The specified joystick identifier is invalid.
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_BADDEVICEID"/> - Windows 95/98/Me: The specified joystick identifier is invalid.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOYERR_UNPLUGGED"/> - The specified joystick is not connected to the system.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOYERR_PARMS"/> - Windows NT/2000/XP: The specified joystick identifier is invalid.
                </para>
            </returns>
            <remarks>
                This function provides access to extended devices such as rudder pedals, point-of-view hats, devices with a large number of buttons, and coordinate systems using up to six axes. For joystick devices that use three axes or fewer and have fewer than four buttons, use the joyGetPos function.
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.joyGetThreshold(System.Int32,System.IntPtr)">
            <summary>
                The joyGetThreshold function queries a joystick for its current movement threshold.
            </summary>
            <param name="uJoyID">
                Identifier of the joystick. Valid values for uJoyID range from zero (<see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/>) to 15, except for Windows NT 4.0. For Windows NT 4.0, valid values are limited to <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/> and <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID2"/>.
            </param>
            <param name="puThreshold">
                Pointer to a variable that contains the movement threshold value.
            </param>
            <returns>
                <para>
                    Returns JOYERR_NOERROR if successful or one of the following error values.
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_NODRIVER"/> - The joystick driver is not present.
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_INVALPARAM"/> - An invalid parameter was passed.
                </para>
            </returns>
            <remarks>
                The movement threshold is the distance the joystick must be moved before a joystick position-change message (<see cref="F:Tao.Platform.Windows.Winmm.MM_JOY1MOVE"/>, <see cref="F:Tao.Platform.Windows.Winmm.MM_JOY1ZMOVE"/>, <see cref="F:Tao.Platform.Windows.Winmm.MM_JOY2MOVE"/>, or <see cref="F:Tao.Platform.Windows.Winmm.MM_JOY2ZMOVE"/>) is sent to a window that has captured the device. The threshold is initially zero.
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.joyReleaseCapture(System.Int32)">
            <summary>
                The joyReleaseCapture function releases the specified captured joystick.
            </summary>
            <param name="uJoyID">
                Identifier of the joystick. Valid values for uJoyID range from zero (<see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/>) to 15, except for Windows NT 4.0. For Windows NT 4.0, valid values are limited to <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/> and <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID2"/>.
            </param>
            <returns>
                <para>
                    Returns <see cref="F:Tao.Platform.Windows.Winmm.JOYERR_NOERROR"/> if successful or one of the following error values.
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_NODRIVER"/> - The joystick driver is not present.
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_INVALPARAM"/> - Windows 95/98/Me: The specified joystick device identifier uJoyID is invalid. Windows NT/2000/XP: The specified joystick identifier is valid, but the joystick has not been captured.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOYERR_PARMS"/> - Windows NT/2000/XP: The specified joystick device identifier uJoyID is invalid.
                </para>
            </returns>
            <remarks>
                Windows 95/98/Me: This method returns JOYERR_NOERROR when passed a valid joystick identifier that has not been captured.
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.joySetCapture(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
                The joySetCature function captures a joystick by causing its messages to be sent to the specified window.
            </summary>
            <param name="hwnd">
                Handle to the window to receive the joystick messages.
            </param>
            <param name="uJoyID">
                Identifier of the joystick. Valid values for uJoyID range from zero (<see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/>) to 15, except for Windows NT 4.0. For Windows NT 4.0, valid values are limited to <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/> and <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID2"/>.
            </param>
            <param name="uPeriod">
                Polling frequency, in milliseconds.
            </param>
            <param name="fChanged">
                Change position flag. Specify TRUE for this parameter to send messages only when the position changes by a value greater than the joystick movement threshold. Otherwise, messages are sent at the polling frequency specified in uPeriod.
            </param>
            <returns>
                <para>
                    Returns JOYERR_NOERROR if successful or one of the following error values.
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_NODRIVER"/> - The joystick driver is not present.
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_INVALPARAM"/> - Windows 95/98/Me: Invalid joystick ID or hwnd is NULL.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOYERR_NOCANDO"/> - Cannot capture joystick input because a required service (such as a Windows timer) is unavailable.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOYERR_UNPLUGGED"/> - The specified joystick is not connected to the system.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOYERR_PARMS"/> - Windows NT/2000/XP: Invalid joystick ID or hwnd is NULL.
                </para>
            </returns>
            <remarks>
                This function fails if the specified joystick is currently captured. Call the joyReleaseCapture function to release the captured joystick, or destroy the window to release the joystick automatically.
            </remarks>
        </member>
        <member name="M:Tao.Platform.Windows.Winmm.joySetThreshold(System.Int32,System.Int32)">
            <summary>
                The joySetThreshold function sets the movement threshold of a joystick.
            </summary>
            <param name="uJoyID">
                Identifier of the joystick. Valid values for uJoyID range from zero (<see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/>) to 15, except for Windows NT 4.0. For Windows NT 4.0, valid values are limited to <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID1"/> and <see cref="F:Tao.Platform.Windows.Winmm.JOYSTICKID2"/>.
            </param>
            <param name="uThreshold">
                New movement threshold.
            </param>
            <returns>
                <para>
                    Returns JOYERR_NOERROR if successful or one of the following error values.
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.Winmm.MMSYSERR_NODRIVER"/> - The joystick driver is not present.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOYERR_PARMS"/> - The specified joystick device identifier uJoyID is invalid.
                </para>
            </returns>
            <remarks>
                The movement threshold is the distance the joystick must be moved before a joystick position-change message (<see cref="F:Tao.Platform.Windows.Winmm.MM_JOY1MOVE"/>, <see cref="F:Tao.Platform.Windows.Winmm.MM_JOY1ZMOVE"/>, <see cref="F:Tao.Platform.Windows.Winmm.MM_JOY2MOVE"/>, or <see cref="F:Tao.Platform.Windows.Winmm.MM_JOY2ZMOVE"/>) is sent to a window that has captured the device. The threshold is initially zero.
            </remarks>
        </member>
        <member name="T:Tao.Platform.Windows.Winmm.JOYCAPS">
            <summary>
                The JOYCAPS structure contains information about the joystick capabilities.
            </summary>
            <remarks>
                <para>
                    <b>Requirements</b>
                </para>
                <para>
                    Windows NT/2000/XP: Included in Windows NT 3.1 and later.
                    Windows 95/98/Me: Included in Windows 95 and later.
                    Header: Declared in Mmsystem.h; include Windows.h.
                    Unicode: Declared as Unicode and ANSI structures.
                </para>
            </remarks>
            <seealso cref="T:Tao.Platform.Windows.Winmm.JOYINFO"/>
            <seealso cref="T:Tao.Platform.Windows.Winmm.JOYINFOEX"/>
            <seealso cref="M:Tao.Platform.Windows.Winmm.joySetCapture(System.Int32,System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wMid">
            <summary>
                Manufacturer identifier. Manufacturer identifiers are defined in Manufacturer and Product Identifiers.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wPid">
            <summary>
                Product identifier. Product identifiers are defined in Manufacturer and Product Identifiers.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.szPname">
            <summary>
                Null-terminated string containing the joystick product name.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wXmin">
            <summary>
                Minimum X-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wXmax">
            <summary>
                Maximum X-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wYmin">
            <summary>
            Minimum Y-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wYmax">
            <summary>
                Maximum Y-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wZmin">
            <summary>
                Minimum Z-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wZmax">
            <summary>
                Maximum Z-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wNumButtons">
            <summary>
                Number of joystick buttons.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wPeriodMin">
            <summary>
                Smallest polling frequency supported when captured by the <see cref="M:Tao.Platform.Windows.Winmm.joySetCapture(System.Int32,System.Int32,System.Int32,System.Boolean)"/> function.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wPeriodMax">
            <summary>
                Largest polling frequency supported when captured by <see cref="M:Tao.Platform.Windows.Winmm.joySetCapture(System.Int32,System.Int32,System.Int32,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wRmin">
            <summary>
                Minimum rudder value. The rudder is a fourth axis of movement.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wRmax">
            <summary>
                Maximum rudder value. The rudder is a fourth axis of movement.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wUmin">
            <summary>
                Minimum u-coordinate (fifth axis) values.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wUmax">
            <summary>
                Maximum u-coordinate (fifth axis) values.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wVmin">
            <summary>
                Minimum v-coordinate (sixth axis) values.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wVmax">
            <summary>
                Maximum v-coordinate (sixth axis) values.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wCaps">
            <summary>
                Joystick capabilities The following flags define individual capabilities that a joystick might have:
            </summary>
            <remarks>
                <see cref="F:Tao.Platform.Windows.Winmm.JOYCAPS_HASZ"/> - Joystick has z-coordinate information.
                <see cref="F:Tao.Platform.Windows.Winmm.JOYCAPS_HASR"/> - Joystick has rudder (fourth axis) information.
                <see cref="F:Tao.Platform.Windows.Winmm.JOYCAPS_HASU"/> - Joystick has u-coordinate (fifth axis) information.
                <see cref="F:Tao.Platform.Windows.Winmm.JOYCAPS_HASV"/> - Joystick has v-coordinate (sixth axis) information.
                <see cref="F:Tao.Platform.Windows.Winmm.JOYCAPS_HASPOV"/> - Joystick has point-of-view information.
                <see cref="F:Tao.Platform.Windows.Winmm.JOYCAPS_POV4DIR"/> - Joystick point-of-view supports discrete values (centered, forward, backward, left, and right).
                <see cref="F:Tao.Platform.Windows.Winmm.JOYCAPS_POVCTS"/> - Joystick point-of-view supports continuous degree bearings.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wMaxAxes">
            <summary>
                Maximum number of axes supported by the joystick.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wNumAxes">
            <summary>
                Number of axes currently in use by the joystick.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.wMaxButtons">
            <summary>
                Maximum number of buttons supported by the joystick.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.szRegKey">
            <summary>
                Null-terminated string containing the registry key for the joystick.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYCAPS.szOEMVxD">
            <summary>
                Null-terminated string identifying the joystick driver OEM.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Winmm.JOYINFO">
            <summary>
            The JOYINFO structure contains information about the joystick position and button state.
            </summary>
            <remarks>
                <para>
                    <b>Requirements</b>
                </para>
                <para>
                    Windows NT/2000/XP: Included in Windows NT 3.1 and later.
                    Windows 95/98/Me: Included in Windows 95 and later.
                    Header: Declared in Mmsystem.h; include Windows.h.
                </para>
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFO.wXpos">
            <summary>
                Current X-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFO.wYpos">
            <summary>
                Current Y-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFO.wZpos">
            <summary>
                Current Z-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFO.wButtons">
            <summary>
                Current state of joystick buttons.
            </summary>
            <remarks>
                <para>According to one or more of the following values:</para>
                <para>
                    <see cref="F:Tao.Platform.Windows.Winmm.JOY_BUTTON1"/> - First joystick button is pressed.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOY_BUTTON2"/> - Second joystick button is pressed.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOY_BUTTON3"/> - Third joystick button is pressed.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOY_BUTTON4"/> - Fourth joystick button is pressed.
                </para>
            </remarks>
        </member>
        <member name="T:Tao.Platform.Windows.Winmm.JOYINFOEX">
            <summary>
                The JOYINFOEX structure contains extended information about the joystick position, point-of-view position, and button state.
            </summary>
            <remarks>
                <para>
                    The value of the dwSize member is also used to identify the version number for the structure when it's passed to the <see cref="M:Tao.Platform.Windows.Winmm.joyGetPosEx(System.Int32,Tao.Platform.Windows.Winmm.JOYINFOEX@)"/> function.
                </para>
                <para>
                    Most devices with a point-of-view control have only five positions. When the JOY_RETURNPOV flag is set, these positions are reported by using the following constants:
                </para>
                <para>
                    <see cref="F:Tao.Platform.Windows.Winmm.JOY_POVBACKWARD"/> - Point-of-view hat is pressed backward. The value 18,000 represents an orientation of 180.00 degrees (to the rear).
                    <see cref="F:Tao.Platform.Windows.Winmm.JOY_POVCENTERED"/> - Point-of-view hat is in the neutral position. The value -1 means the point-of-view hat has no angle to report.
                    <see cref="F:Tao.Platform.Windows.Winmm.JOY_POVFORWARD"/> - Point-of-view hat is pressed forward. The value 0 represents an orientation of 0.00 degrees (straight ahead).
                    <see cref="F:Tao.Platform.Windows.Winmm.JOY_POVLEFT"/> - Point-of-view hat is being pressed to the left. The value 27,000 represents an orientation of 270.00 degrees (90.00 degrees to the left).
                    <see cref="F:Tao.Platform.Windows.Winmm.JOY_POVRIGHT"/> - Point-of-view hat is pressed to the right. The value 9,000 represents an orientation of 90.00 degrees (to the right).
                </para>
                <para>
                    The default joystick driver currently supports these five discrete directions. If an application can accept only the defined point-of-view values, it must use the JOY_RETURNPOV flag. If an application can accept other degree readings, it should use the JOY_RETURNPOVCTS flag to obtain continuous data if it is available. The JOY_RETURNPOVCTS flag also supports the JOY_POV constants used with the JOY_RETURNPOV flag.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Winmm.joyGetPosEx(System.Int32,Tao.Platform.Windows.Winmm.JOYINFOEX@)"/>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwSize">
            <summary>
            Size, in bytes, of this structure.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwFlags">
            <summary>
            Flags indicating the valid information returned in this structure. Members that do not contain valid information are set to zero.
            </summary>
            <remarks>
            <para>
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNALL"/> - Equivalent to setting all of the JOY_RETURN bits except JOY_RETURNRAWDATA.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNBUTTONS"/> - The dwButtons member contains valid information about the state of each joystick button.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNCENTERED"/> - Centers the joystick neutral position to the middle value of each axis of movement.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNPOV"/> - The dwPOV member contains valid information about the point-of-view control, expressed in discrete units.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNPOVCTS"/> - The dwPOV member contains valid information about the point-of-view control expressed in continuous, one-hundredth degree units.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNR"/> - The dwRpos member contains valid rudder pedal data. This information represents another (fourth) axis.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNRAWDATA"/>	- Data stored in this structure is uncalibrated joystick readings.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNU"/> - The dwUpos member contains valid data for a fifth axis of the joystick, if such an axis is available, or returns zero otherwise.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNV"/> - The dwVpos member contains valid data for a sixth axis of the joystick, if such an axis is available, or returns zero otherwise.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNX"/> - The dwXpos member contains valid data for the x-coordinate of the joystick.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNY"/> - The dwYpos member contains valid data for the y-coordinate of the joystick.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_RETURNZ"/> - The dwZpos member contains valid data for the z-coordinate of the joystick.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_USEDEADZONE"/> - Expands the range for the neutral position of the joystick and calls this range the dead zone. The joystick driver returns a constant value for all positions in the dead zone.
            </para>
            <para>
                The following flags provide data to calibrate a joystick and are intended for custom calibration applications.
            </para>
            <para>
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READ3"/> - Read the x-, y-, and z-coordinates and store the raw values in dwXpos, dwYpos, and dwZpos.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READ4"/> - Read the rudder information and the x-, y-, and z-coordinates and store the raw values in dwXpos, dwYpos, dwZpos, and dwRpos.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READ5"/> - Read the rudder information and the x-, y-, z-, and u-coordinates and store the raw values in dwXpos, dwYpos, dwZpos, dwRpos, and dwUpos.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READ6"/> - Read the raw v-axis data if a joystick mini driver is present that will provide the data. Returns zero otherwise.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READALWAYS"/> - Read the joystick port even if the driver does not detect a device.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READRONLY"/> - Read the rudder information if a joystick mini-driver is present that will provide the data and store the raw value in dwRpos. Return zero otherwise.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READXONLY"/> - Read the x-coordinate and store the raw (uncalibrated) value in dwXpos.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READXYONLY"/> - Reads the x- and y-coordinates and place the raw values in dwXpos and dwYpos.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READYONLY"/> - Reads the y-coordinate and store the raw value in dwYpos.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READZONLY"/> - Read the z-coordinate and store the raw value in dwZpos.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READUONLY"/> - Read the u-coordinate if a joystick mini-driver is present that will provide the data and store the raw value in dwUpos. Return zero otherwise.
                <see cref="F:Tao.Platform.Windows.Winmm.JOY_CAL_READVONLY"/> - Read the v-coordinate if a joystick mini-driver is present that will provide the data and store the raw value in dwVpos. Return zero otherwise.
            </para>
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwXpos">
            <summary>
            Current X-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwYpos">
            <summary>
            Current Y-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwZpos">
            <summary>
            Current Z-coordinate.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwRpos">
            <summary>
            Current position of the rudder or fourth joystick axis.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwUpos">
            <summary>
            Current fifth axis position.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwVpos">
            <summary>
            Current sixth axis position.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwButtons">
            <summary>
            Current state of the 32 joystick buttons. The value of this member can be set to any combination of JOY_BUTTONn flags, where n is a value in the range of 1 through 32 corresponding to the button that is pressed.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwButtonNumber">
            <summary>
            Current button number that is pressed.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwPOV">
            <summary>
            Current position of the point-of-view control. Values for this member are in the range 0 through 35,900. These values represent the angle, in degrees, of each view multiplied by 100.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwReserved1">
            <summary>
            Reserved; do not use.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Winmm.JOYINFOEX.dwReserved2">
            <summary>
            Reserved; do not use.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.User">
            <summary>
                User binding for .NET, implementing Windows-specific user functionality.
            </summary>
            <remarks>
                Binds functions and definitions in user32.dll.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.User.USER_NATIVE_LIBRARY">
            <summary>
                Specifies User32's native library archive.
            </summary>
            <remarks>
                Specifies user32.dll for Windows.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.User.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.StdCall"/>.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_VREDRAW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_HREDRAW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_DBLCLKS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_OWNDC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_CLASSDC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_PARENTDC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_NOCLOSE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_SAVEBITS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_BYTEALIGNCLIENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_BYTEALIGNWINDOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_GLOBALCLASS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_IME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CS_DROPSHADOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CDS_UPDATEREGISTRY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CDS_TEST">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.CDS_FULLSCREEN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.DISP_CHANGE_SUCCESSFUL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.DISP_CHANGE_RESTART">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.DISP_CHANGE_FAILED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.ENUM_CURRENT_SETTINGS">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.User.ChangeDisplaySettings(Tao.Platform.Windows.Gdi.DEVMODE@,System.Int32)">
            <summary>
                <para>
                    The <b>ChangeDisplaySettings</b> function changes the settings of the default
                    display device to the specified graphics mode.
                </para>
                <para>
                    To change the settings of a specified display device, use the
                    <b>ChangeDisplaySettingsEx</b> function.
                </para>
            </summary>
            <param name="devMode">
                <para>
                    Pointer to a <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure that describes the new
                    graphics mode.  If <i>devMode</i> is NULL, all the values currently in the
                    registry will be used for the display setting.  Passing NULL for the
                    <i>devMode</i> parameter and 0 for the <i>flags</i> parameter is the easiest
                    way to return to the default mode after a dynamic mode change.
                </para>
                <para>
                    The <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmSize"/> member of <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    must be initialized to the size, in bytes, of the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    structure.  The <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDriverExtra"/> member of
                    <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> must be initialized to indicate the number of bytes
                    of private driver data following the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure.  In
                    addition, you can use any or all of the following members of the
                    <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmBitsPerPel"/></term>
                            <description>Bits per pixel.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsWidth"/></term>
                            <description>Pixel width.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsHeight"/></term>
                            <description>Pixel height.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFlags"/></term>
                            <description>Mode flags.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFrequency"/></term>
                            <description>Mode frequency.</description>
                        </item>
                        <item>
                            <term>dmPosition</term>
                            <description>
                                <b>Windows 98/Me, Windows 2000/XP:</b> Position of the device in
                                a multimonitor configuration.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    In addition to using one or more of the preceding <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    members, you must also set one or more of the following values in the
                    <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmFields"/> member to change the display setting:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_BITSPERPEL"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmBitsPerPel"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_PELSWIDTH"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsWidth"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_PELSHEIGHT"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsHeight"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFLAGS"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFlags"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFREQUENCY"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFrequency"/> value.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DM_POSITION" </term>
                            <description>
                                <b>Windows 98/Me, Windows 2000/XP:</b> Use the dmPosition value.
                            </description>
                        </item>
                    </list>
                </para>
            </param>
            <param name="flags">
                <para>
                    Indicates how the graphics mode should be changed.  This parameter can be one
                    of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>0</term>
                            <description>
                                The graphics mode for the current screen will be changed
                                dynamically.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_FULLSCREEN" </term>
                            <description>
                                <para>
                                    The mode is temporary in nature.
                                </para>
                                <para>
                                    <b>Windows NT/2000/XP:</b> If you change to and from another
                                    desktop, this mode will not be reset.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_GLOBAL" </term>
                            <description>
                                The settings will be saved in the global settings area so that
                                they will affect all users on the machine.  Otherwise, only the
                                settings for the user are modified.  This flag is only valid when
                                specified with the see cref="Gdi.CDS_UPDATEREGISTRY"  flag.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_NORESET" </term>
                            <description>
                                The settings will be saved in the registry, but will not take
                                affect.  This flag is only valid when specified with the
                                see cref="Gdi.CDS_UPDATEREGISTRY"  flag.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_RESET" </term>
                            <description>
                                The settings should be changed, even if the requested settings are
                                the same as the current settings.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_SET_PRIMARY" </term>
                            <description>
                                This device will become the primary device.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_TEST" </term>
                            <description>
                                The system tests if the requested graphics mode could be set.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_UPDATEREGISTRY" </term>
                            <description>
                                The graphics mode for the current screen will be changed
                                dynamically and the graphics mode will be updated in the registry.
                                The mode information is stored in the USER profile.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    Specifying see cref="Gdi.CDS_TEST"  allows an application to determine
                    which graphics modes are actually valid, without causing the system to
                    change to that graphics mode.
                </para>
                <para>
                    If see cref="Gdi.CDS_UPDATEREGISTRY"  is specified and it is possible to
                    change the graphics mode dynamically, the information is stored in the
                    registry and see cref="Gdi.DISP_CHANGE_SUCCESSFUL"  is returned.  If it is
                    not possible to change the graphics mode dynamically, the information is
                    stored in the registry and see cref="Gdi.DISP_CHANGE_RESTART"  is returned.
                </para>
                <para>
                    <b>Windows NT/2000/XP:</b>  If see cref="Gdi.CDS_UPDATEREGISTRY"  is
                    specified and the information could not be stored in the registry, the
                    graphics mode is not changed and see cref="Gdi.DISP_CHANGE_NOTUPDATED"  is
                    returned.
                </para>
            </param>
            <returns>
                <para>
                    The <b>ChangeDisplaySettings</b> function returns one of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_SUCCESSFUL" </term>
                            <description>
                                The settings change was successful.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_BADDUALVIEW" </term>
                            <description>
                                <b>Windows XP:</b>  The settings change was unsuccessful because
                                system is DualView capable.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_BADFLAGS" </term>
                            <description>
                                An invalid set of flags was passed in.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_BADMODE" </term>
                            <description>
                                The graphics mode is not supported.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_BADPARAM" </term>
                            <description>
                                An invalid parameter was passed in.  This can include an invalid
                                flag or combination of flags.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_FAILED" </term>
                            <description>
                                The display driver failed the specified graphics mode.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_NOTUPDATED" </term>
                            <description>
                                <b>Windows NT/2000/XP:</b>  Unable to write settings to the
                                registry.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_RESTART" </term>
                            <description>
                                The computer must be restarted in order for the graphics mode to
                                work.
                            </description>
                        </item>
                    </list>
                </para>
            </returns>
            <remarks>
                <para>
                    To ensure that the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure passed to
                    <b>ChangeDisplaySettings</b> is valid and contains only values supported by
                    the display driver, use the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> returned by the
                    <see cref="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)"/> function.
                </para>
                <para>
                    When the display mode is changed dynamically, the <b>WM_DISPLAYCHANGE</b>
                    message is sent to all running applications with the following message
                    parameters:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>wParam</term>
                            <description>New bits per pixel.</description>
                        </item>
                        <item>
                            <term>LOWORD(lParam)</term>
                            <description>New pixel width.</description>
                        </item>
                        <item>
                            <term>HIWORD(lParam)</term>
                            <description>New pixel height.</description>
                        </item>
                    </list>
                </para>
                <para>
                    <b>Windows 95/98/Me:</b>  If the calling thread has any windows,
                    <b>ChangeDisplaySettings</b> sends them the <b>WM_DISPLAYCHANGE</b> message
                    immediately (for windows in all other threads, the message is sent when the
                    thread can receive nonqueued messages).  This may cause the shell to get its
                    message too soon and could squash icons.  To avoid this problem, have
                    <b>ChangeDisplaySettings</b> do resolution switching by calling on a thread
                    with no windows, for example, a new thread.
                </para>
            </remarks>
            seealso cref="CreateDC" 
            <seealso cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
            <seealso cref="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)"/>
        </member>
        <member name="M:Tao.Platform.Windows.User.ChangeDisplaySettings(System.IntPtr,System.Int32)">
            <summary>
                <para>
                    The <b>ChangeDisplaySettings</b> function changes the settings of the default
                    display device to the specified graphics mode.
                </para>
                <para>
                    To change the settings of a specified display device, use the
                    <b>ChangeDisplaySettingsEx</b> function.
                </para>
            </summary>
            <param name="devMode">
                <para>
                    Pointer to a <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure that describes the new
                    graphics mode.  If <i>devMode</i> is NULL, all the values currently in the
                    registry will be used for the display setting.  Passing NULL for the
                    <i>devMode</i> parameter and 0 for the <i>flags</i> parameter is the easiest
                    way to return to the default mode after a dynamic mode change.
                </para>
                <para>
                    The <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmSize"/> member of <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    must be initialized to the size, in bytes, of the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    structure.  The <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDriverExtra"/> member of
                    <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> must be initialized to indicate the number of bytes
                    of private driver data following the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure.  In
                    addition, you can use any or all of the following members of the
                    <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmBitsPerPel"/></term>
                            <description>Bits per pixel.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsWidth"/></term>
                            <description>Pixel width.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsHeight"/></term>
                            <description>Pixel height.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFlags"/></term>
                            <description>Mode flags.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFrequency"/></term>
                            <description>Mode frequency.</description>
                        </item>
                        <item>
                            <term>dmPosition</term>
                            <description>
                                <b>Windows 98/Me, Windows 2000/XP:</b> Position of the device in
                                a multimonitor configuration.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    In addition to using one or more of the preceding <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
                    members, you must also set one or more of the following values in the
                    <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmFields"/> member to change the display setting:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_BITSPERPEL"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmBitsPerPel"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_PELSWIDTH"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsWidth"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_PELSHEIGHT"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsHeight"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFLAGS"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFlags"/> value.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFREQUENCY"/></term>
                            <description>
                                Use the <see cref="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFrequency"/> value.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DM_POSITION" /&gt;</term>
                            <description>
                                <b>Windows 98/Me, Windows 2000/XP:</b> Use the dmPosition value.
                            </description>
                        </item>
                    </list>
                </para>
            </param>
            <param name="flags">
                <para>
                    Indicates how the graphics mode should be changed.  This parameter can be one
                    of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>0</term>
                            <description>
                                The graphics mode for the current screen will be changed
                                dynamically.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_FULLSCREEN" </term>
                            <description>
                                <para>
                                    The mode is temporary in nature.
                                </para>
                                <para>
                                    <b>Windows NT/2000/XP:</b> If you change to and from another
                                    desktop, this mode will not be reset.
                                </para>
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_GLOBAL" </term>
                            <description>
                                The settings will be saved in the global settings area so that
                                they will affect all users on the machine.  Otherwise, only the
                                settings for the user are modified.  This flag is only valid when
                                specified with the see cref="Gdi.CDS_UPDATEREGISTRY"  flag.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_NORESET" </term>
                            <description>
                                The settings will be saved in the registry, but will not take
                                affect.  This flag is only valid when specified with the
                                see cref="Gdi.CDS_UPDATEREGISTRY"  flag.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_RESET" </term>
                            <description>
                                The settings should be changed, even if the requested settings are
                                the same as the current settings.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_SET_PRIMARY" </term>
                            <description>
                                This device will become the primary device.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_TEST" /&gt;</term>
                            <description>
                                The system tests if the requested graphics mode could be set.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.CDS_UPDATEREGISTRY" /&gt;</term>
                            <description>
                                The graphics mode for the current screen will be changed
                                dynamically and the graphics mode will be updated in the registry.
                                The mode information is stored in the USER profile.
                            </description>
                        </item>
                    </list>
                </para>
                <para>
                    Specifying see cref="Gdi.CDS_TEST" /&gt; allows an application to determine
                    which graphics modes are actually valid, without causing the system to
                    change to that graphics mode.
                </para>
                <para>
                    If see cref="Gdi.CDS_UPDATEREGISTRY" /&gt; is specified and it is possible to
                    change the graphics mode dynamically, the information is stored in the
                    registry and see cref="Gdi.DISP_CHANGE_SUCCESSFUL" /&gt; is returned.  If it is
                    not possible to change the graphics mode dynamically, the information is
                    stored in the registry and see cref="Gdi.DISP_CHANGE_RESTART" /&gt; is returned.
                </para>
                <para>
                    <b>Windows NT/2000/XP:</b>  If see cref="Gdi.CDS_UPDATEREGISTRY" /&gt; is
                    specified and the information could not be stored in the registry, the
                    graphics mode is not changed and see cref="Gdi.DISP_CHANGE_NOTUPDATED" /&gt; is
                    returned.
                </para>
            </param>
            <returns>
                <para>
                    The <b>ChangeDisplaySettings</b> function returns one of the following values:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_SUCCESSFUL" /&gt;</term>
                            <description>
                                The settings change was successful.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_BADDUALVIEW" /&gt;</term>
                            <description>
                                <b>Windows XP:</b>  The settings change was unsuccessful because
                                system is DualView capable.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_BADFLAGS" /&gt;</term>
                            <description>
                                An invalid set of flags was passed in.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_BADMODE" </term>
                            <description>
                                The graphics mode is not supported.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_BADPARAM" </term>
                            <description>
                                An invalid parameter was passed in.  This can include an invalid
                                flag or combination of flags.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_FAILED" /&gt;</term>
                            <description>
                                The display driver failed the specified graphics mode.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_NOTUPDATED" /&gt;</term>
                            <description>
                                <b>Windows NT/2000/XP:</b>  Unable to write settings to the
                                registry.
                            </description>
                        </item>
                        <item>
                            <term>see cref="Gdi.DISP_CHANGE_RESTART" /&gt;</term>
                            <description>
                                The computer must be restarted in order for the graphics mode to
                                work.
                            </description>
                        </item>
                    </list>
                </para>
            </returns>
            <remarks>
                <para>
                    To ensure that the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> structure passed to
                    <b>ChangeDisplaySettings</b> is valid and contains only values supported by
                    the display driver, use the <see cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/> returned by the
                    <see cref="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)"/> function.
                </para>
                <para>
                    When the display mode is changed dynamically, the <b>WM_DISPLAYCHANGE</b>
                    message is sent to all running applications with the following message
                    parameters:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Value</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term>wParam</term>
                            <description>New bits per pixel.</description>
                        </item>
                        <item>
                            <term>LOWORD(lParam)</term>
                            <description>New pixel width.</description>
                        </item>
                        <item>
                            <term>HIWORD(lParam)</term>
                            <description>New pixel height.</description>
                        </item>
                    </list>
                </para>
                <para>
                    <b>Windows 95/98/Me:</b>  If the calling thread has any windows,
                    <b>ChangeDisplaySettings</b> sends them the <b>WM_DISPLAYCHANGE</b> message
                    immediately (for windows in all other threads, the message is sent when the
                    thread can receive nonqueued messages).  This may cause the shell to get its
                    message too soon and could squash icons.  To avoid this problem, have
                    <b>ChangeDisplaySettings</b> do resolution switching by calling on a thread
                    with no windows, for example, a new thread.
                </para>
            </remarks>
            seealso cref="CreateDC" /&gt;
            <seealso cref="T:Tao.Platform.Windows.Gdi.DEVMODE"/>
            <seealso cref="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)"/>
        </member>
        <member name="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)">
            <summary>
            
            </summary>
            <param name="deviceName"></param>
            <param name="modeNumber"></param>
            <param name="devMode"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.User.GetDC(System.IntPtr)">
            <summary>
                <para>
                    The <b>GetDC</b> function retrieves a handle to a display device context (DC)
                    for the client area of a specified window or for the entire screen.  You can
                    use the returned handle in subsequent GDI functions to draw in the DC.
                </para>
                <para>
                    The see cref="GetDCEx" /&gt; function is an extension to <b>GetDC</b>, which
                    gives an application more control over how and whether clipping occurs in the
                    client area.
                </para>
            </summary>
            <param name="windowHandle">
                <para>
                    Handle to the window whose DC is to be retrieved.  If this value is null,
                    <b>GetDC</b> retrieves the DC for the entire screen.
                </para>
                <para>
                    <b>Windows 98/Me, Windows 2000/XP:</b> To get the DC for a specific display
                    monitor, use the see cref="EnumDisplayMonitors" /&gt; and
                    see cref="Gdi.CreateDC" /&gt; functions.
                </para>
            </param>
            <returns>
                <para>
                    If the function succeeds, the return value is a handle to the DC for the
                    specified window's client area.
                </para>
                <para>
                    If the function fails, the return value is null.
                </para>
                <para>
                    <b>Windows NT/2000/XP:</b> To get extended error information, call
                    <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
                </para>
            </returns>
            <remarks>
                <para>
                    The <b>GetDC</b> function retrieves a common, class, or private DC depending
                    on the class style of the specified window.  For class and private DCs,
                    <b>GetDC</b> leaves the previously assigned attributes unchanged.  However,
                    for common DCs, <b>GetDC</b> assigns default attributes to the DC each time
                    it is retrieved.  For example, the default font is System, which is a bitmap
                    font.  Because of this, the handle for a common DC returned by <b>GetDC</b>
                    does not tell you what font, color, or brush was used when the window was
                    drawn.  To determine the font, call see cref="GetTextFace" /&gt;.
                </para>
                <para>
                    Note that the handle to the DC can only be used by a single thread at any one
                    time.
                </para>
                <para>
                    After painting with a common DC, the <see cref="M:Tao.Platform.Windows.User.ReleaseDC(System.IntPtr,System.IntPtr)"/> function must
                    be called to release the DC.  Class and private DCs do not have to be
                    released.  <see cref="M:Tao.Platform.Windows.User.ReleaseDC(System.IntPtr,System.IntPtr)"/> must be called from the same thread that
                    called <b>GetDC</b>.  The number of DCs is limited only by available memory.
                </para>
                <para>
                    <b>Windows 95/98/Me:</b> There are only 5 common DCs available per thread,
                    thus failure to release a DC can prevent other applications from accessing
                    one.
                </para>
            </remarks>
            seealso cref="GetDCEx" /&gt;
            <seealso cref="M:Tao.Platform.Windows.User.ReleaseDC(System.IntPtr,System.IntPtr)"/>
            seealso cref="GetTextFace" /&gt;
            seealso cref="GetWindowDC" /&gt;
        </member>
        <member name="M:Tao.Platform.Windows.User.ReleaseDC(System.IntPtr,System.IntPtr)">
            <summary>
                <para>
                    The <b>ReleaseDC</b> function releases a device context (DC), freeing it for
                    use by other applications.  The effect of the <b>ReleaseDC</b> function
                    depends on the type of DC.  It frees only common and window DCs.  It has no
                    effect on class or private DCs.
                </para>
            </summary>
            <param name="windowHandle">
                <para>
                    Handle to the window whose DC is to be released.
                </para>
            </param>
            <param name="deviceContext">
                <para>
                    Handle to the DC to be released.
                </para>
            </param>
            <returns>
                <para>
                    The return value indicates whether the DC was released.  If the DC was
                    released, the return value is true.
                </para>
                <para>
                    If the DC was not released, the return value is false.
                </para>
            </returns>
            <remarks>
                <para>
                    The application must call the <b>ReleaseDC</b> function for each call to the
                    see cref="GetWindowDC" /&gt; function and for each call to the
                    <see cref="M:Tao.Platform.Windows.User.GetDC(System.IntPtr)"/> function that retrieves a common DC.
                </para>
                <para>
                    An application cannot use the <b>ReleaseDC</b> function to release a DC that
                    was created by calling the see cref="Gdi.CreateDC" /&gt; function; instead, it
                    must use the see cref="Gdi.DeleteDC" /&gt; function.  <b>ReleaseDC</b> must be
                    called from the same thread that called <b>GetDC</b>.
                </para>
            </remarks>
            seealso cref="Gdi.CreateDC" /&gt;
            seealso cref="Gdi.DeleteDC" /&gt;
            <seealso cref="M:Tao.Platform.Windows.User.GetDC(System.IntPtr)"/>
            seealso cref="GetWindowDC" /&gt;
        </member>
        <member name="M:Tao.Platform.Windows.User.SetParent(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="hWndChild"></param>
            <param name="hWndNewParent"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.User.FindWindow(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="lpClassName"></param>
            <param name="lpWindowName"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.User.ShowWindow(System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="hWnd"></param>
            <param name="nCmdShow"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.User.SetWindowPos(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
            <summary>
            
            </summary>
            <param name="hWnd"></param>
            <param name="hWndInsertAfter"></param>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="cx"></param>
            <param name="cy"></param>
            <param name="uFlags"></param>
            <returns></returns>
        </member>
        <member name="T:Tao.Platform.Windows.User.SHOWWINDOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_HIDE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_SHOWNORMAL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_NORMAL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_SHOWMINIMIZED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_SHOWMAXIMIZED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_MAXIMIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_SHOWNOACTIVATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_SHOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_MINIMIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_SHOWMINNOACTIVE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_SHOWNA">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_RESTORE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_SHOWDEFAULT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_FORCEMINIMIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.User.SHOWWINDOW.SW_MAX">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.SimpleOpenGlControl">
            <summary>
                Provides a simple OpenGL control allowing quick development of Windows Forms-based
                OpenGL applications.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.#ctor">
            <summary>
                Constructor.  Creates contexts and sets properties.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.Dispose(System.Boolean)">
            <summary>
                Disposes the control.
            </summary>
            <param name="disposing">Was the disposed manually called?</param>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.InitializeBackground">
            <summary>
                Loads the bitmap from the assembly's manifest resource.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.InitializeComponent">
            <summary>
                Required for designer support.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.InitializeStyles">
            <summary>
                Initializes the control's styles.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.DestroyContexts">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.Draw">
            <summary>
                Sends an see cref="UserControl.Invalidate"  command to this control, thus
                forcing a redraw to occur.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.InitializeContexts">
            <summary>
                Creates the OpenGL contexts.
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.MakeCurrent">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.SwapBuffers">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
                Paints the control.
            </summary>
            <param name="e">The paint event arguments.</param>
        </member>
        <member name="M:Tao.Platform.Windows.SimpleOpenGlControl.OnPaintBackground(System.Windows.Forms.PaintEventArgs)">
            <summary>
                Paints the background.
            </summary>
            <param name="e"></param>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.LogScaleX">
            <summary>
            Gets the number of logical pixels or dots per inch (dpi) in X-direction
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.LogScaleY">
            <summary>
            Gets the number of logical pixels or dots per inch (dpi) in Y-direction
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.AccumBits">
            <summary>
                Gets and sets the OpenGL control's accumulation buffer depth.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.ColorBits">
            <summary>
                Gets and sets the OpenGL control's color buffer depth.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.DepthBits">
            <summary>
                Gets and sets the OpenGL control's depth buffer (Z-buffer) depth.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.StencilBits">
            <summary>
                Gets and sets the OpenGL control's stencil buffer depth.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.AutoCheckErrors">
            <summary>
                Gets and sets the OpenGL control's automatic sending of a glGetError command
                after drawing.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.AutoFinish">
            <summary>
                Gets and sets the OpenGL control's automatic sending of a glFinish command
                after drawing.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.AutoMakeCurrent">
            <summary>
                Gets and sets the OpenGL control's automatic forcing of the rendering context to
                be current before drawing.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.AutoSwapBuffers">
            <summary>
                Gets and sets the OpenGL control's automatic sending of a SwapBuffers command
                after drawing.
            </summary>
        </member>
        <member name="P:Tao.Platform.Windows.SimpleOpenGlControl.CreateParams">
            <summary>
                Overrides the control's class style parameters.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Gdi">
            <summary>
                GDI binding for .NET, implementing Windows-specific GDI functionality.
            </summary>
            <remarks>
                Binds functions and definitions in gdi32.dll.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GDI_NATIVE_LIBRARY">
            <summary>
                Specifies GDI's native library archive.
            </summary>
            <remarks>
                Specifies gdi32.dll for Windows.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.StdCall"/>.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_TYPE_RGBA">
            <summary>
                RGBA pixels.  Each pixel has four components: red, green, blue, and alpha.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_TYPE_COLORINDEX">
            <summary>
                Color-index pixels.  Each pixel uses a color-index value.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_DOUBLEBUFFER">
            <summary>
                The layer plane is double-buffered.  A layer plane can be double-buffered
                even when the main plane is single-buffered and vice versa.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_STEREO">
            <summary>
                The layer plane is stereoscopic.  A layer plane can be stereoscopic even
                when the main plane is monoscopic and vice versa.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SUPPORT_GDI">
            <summary>
                The layer plane supports GDI drawing.  The current implementation of OpenGL
                doesn't support this flag.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SUPPORT_OPENGL">
            <summary>
                The layer plane supports OpenGL drawing.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SHARE_DEPTH">
            <summary>
                The layer plane shares the depth buffer with the main plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SHARE_STENCIL">
            <summary>
                The layer plane shares the stencil buffer with the main plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SHARE_ACCUM">
            <summary>
                The layer plane shares the accumulation buffer with the main plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SWAP_EXCHANGE">
            <summary>
                In a double-buffered layer plane, swapping the color buffer exchanges the
                front buffer and back buffer contents.  The back buffer then contains the
                contents of the front buffer before the swap. This flag is a hint only and
                might not be provided by a driver.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_SWAP_COPY">
            <summary>
                In a double-buffered layer plane, swapping the color buffer copies the back
                buffer contents to the front buffer.  The swap does not affect the back
                buffer contents. This flag is a hint only and might not be provided by a driver.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LPD_TRANSPARENT">
            <summary>
                Contains a transparent color or index value that enables underlying layers
                to show through this layer.  All layer planes, except the lowest-numbered
                underlay layer, have a transparent color or index.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_TYPE_RGBA">
            <summary>
                RGBA pixels.  Each pixel has four components in this order: red, green, blue,
                and alpha.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_TYPE_COLORINDEX">
            <summary>
                Color-index pixels.  Each pixel uses a color-index value.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_MAIN_PLANE">
            <summary>
                The layer is the main plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_OVERLAY_PLANE">
            <summary>
                The layer is the overlay plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_UNDERLAY_PLANE">
            <summary>
                The layer is the underlay plane.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_DOUBLEBUFFER">
            <summary>
                <para>
                    The buffer is double-buffered.  This flag and <see cref="F:Tao.Platform.Windows.Gdi.PFD_SUPPORT_GDI"/>
                    are mutually exclusive in the current generic implementation.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_STEREO">
            <summary>
                <para>
                    The buffer is stereoscopic.  This flag is not supported in the current
                    generic implementation.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_DRAW_TO_WINDOW">
            <summary>
                <para>
                    The buffer can draw to a window or device surface.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_DRAW_TO_BITMAP">
            <summary>
                <para>
                    The buffer can draw to a memory bitmap.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SUPPORT_GDI">
            <summary>
                <para>
                    The buffer supports GDI drawing.  This flag and
                    <see cref="F:Tao.Platform.Windows.Gdi.PFD_DOUBLEBUFFER"/> are mutually exclusive in the current generic
                    implementation.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SUPPORT_OPENGL">
            <summary>
                <para>
                    The buffer supports OpenGL drawing.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_GENERIC_FORMAT">
            <summary>
                <para>
                    The pixel format is supported by the GDI software implementation, which is
                    also known as the generic implementation.  If this bit is clear, the pixel
                    format is supported by a device driver or hardware.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_NEED_PALETTE">
            <summary>
                <para>
                    The buffer uses RGBA pixels on a palette-managed device.  A logical palette
                    is required to achieve the best results for this pixel type.  Colors in the
                    palette should be specified according to the values of the <b>cRedBits</b>,
                    <b>cRedShift</b>, <b>cGreenBits</b>, <b>cGreenShift</b>, <b>cBluebits</b>,
                    and <b>cBlueShift</b> members.  The palette should be created and realized in
                    the device context before calling <see cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/>.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_NEED_SYSTEM_PALETTE">
            <summary>
                <para>
                    Defined in the pixel format descriptors of hardware that supports one
                    hardware palette in 256-color mode only.  For such systems to use
                    hardware acceleration, the hardware palette must be in a fixed order
                    (for example, 3-3-2) when in RGBA mode or must match the logical palette
                    when in color-index mode.
                </para>
                <para>
                    When this flag is set, you must call see cref="SetSystemPaletteUse" /> in
                    your program to force a one-to-one mapping of the logical palette and the
                    system palette.  If your OpenGL hardware supports multiple hardware palettes
                    and the device driver can allocate spare hardware palettes for OpenGL, this
                    flag is typically clear.
                </para>
                <para>
                    This flag is not set in the generic pixel formats.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SWAP_EXCHANGE">
            <summary>
                <para>
                    Specifies the content of the back buffer in the double-buffered main color
                    plane following a buffer swap.  Swapping the color buffers causes the
                    exchange of the back buffer's content with the front buffer's content.
                    Following the swap, the back buffer's content contains the front buffer's
                    content before the swap. <b>PFD_SWAP_EXCHANGE</b> is a hint only and might
                    not be provided by a driver.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SWAP_COPY">
            <summary>
                <para>
                    Specifies the content of the back buffer in the double-buffered main color
                    plane following a buffer swap.  Swapping the color buffers causes the content
                    of the back buffer to be copied to the front buffer.  The content of the back
                    buffer is not affected by the swap.  <b>PFD_SWAP_COPY</b> is a hint only and
                    might not be provided by a driver.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SWAP_LAYER_BUFFERS">
            <summary>
                <para>
                    Indicates whether a device can swap individual layer planes with pixel
                    formats that include double-buffered overlay or underlay planes.
                    Otherwise all layer planes are swapped together as a group.  When this
                    flag is set, <see cref="M:Tao.Platform.Windows.Wgl.wglSwapLayerBuffers(System.IntPtr,System.Int32)"/> is supported.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_GENERIC_ACCELERATED">
            <summary>
                <para>
                    The pixel format is supported by a device driver that accelerates the generic
                    implementation.  If this flag is clear and the
                    <see cref="F:Tao.Platform.Windows.Gdi.PFD_GENERIC_FORMAT"/> flag is set, the pixel format is supported
                    by the generic implementation only.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_SUPPORT_DIRECTDRAW">
            <summary>
                <para>
                    The buffer supports DirectDraw drawing.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_DEPTH_DONTCARE">
            <summary>
                <para>
                    The requested pixel format can either have or not have a depth buffer.  To
                    select a pixel format without a depth buffer, you must specify this flag.
                    The requested pixel format can be with or without a depth buffer.  Otherwise,
                    only pixel formats with a depth buffer are considered.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_DOUBLEBUFFER_DONTCARE">
            <summary>
                <para>
                    The requested pixel format can be either single- or double-buffered.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PFD_STEREO_DONTCARE">
            <summary>
                <para>
                    The requested pixel format can be either monoscopic or stereoscopic.
                </para>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DM_BITSPERPEL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DM_PELSWIDTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DM_PELSHEIGHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFLAGS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DM_DISPLAYFREQUENCY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.OUT_TT_PRECIS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.CLIP_DEFAULT_PRECIS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEFAULT_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DRAFT_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PROOF_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.NONANTIALIASED_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.ANTIALIASED_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.CLEARTYPE_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.CLEARTYPE_NATURAL_QUALITY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEFAULT_PITCH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.FIXED_PITCH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.VARIABLE_PITCH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.MONO_FONT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.ANSI_CHARSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEFAULT_CHARSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.SYMBOL_CHARSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.SHIFTJIS_CHARSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.FF_DONTCARE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.FW_BOLD">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi._SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.ChoosePixelFormat(System.IntPtr,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)">
             <summary>
             The <b>ChoosePixelFormat</b> function attempts to match an appropriate pixel format supported by a device context
             to a given pixel format specification.
             </summary>
             <param name="deviceContext">
             Specifies the device context that the function examines to determine the best match for the pixel format
             descriptor pointed to by <i>ppfd</i>.
             </param>
             <param name="pixelFormatDescriptor">
             <para>
            		Pointer to a <see cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/> structure that specifies the requested pixel format.
            		In this context, the members of the <b>PIXELFORMATDESCRIPTOR</b> structure that <i>ppfd</i>
            		points to are used as follows:
            	</para>
            	<para>
            		<b>nSize</b><br/>
            		Specifies the size of the <b>PIXELFORMATDESCRIPTOR</b> data structure. Set this member to
            		<c>sizeof(PIXELFORMATDESCRIPTOR)</c>.
            	</para>
            	<para>
            		<b>nVersion</b><br/>
            		Specifies the version number of the <b>PIXELFORMATDESCRIPTOR</b> data structure. Set this member to 1.
            	</para>
            	<para>
            		<b>dwFlags</b><br/>
            		A set of bit flags that specify properties of the pixel buffer. You can combine the following bit
            		flag constants by using bitwise-OR.<br/><br/>
            		If any of the following flags are set, the <b>ChoosePixelFormat</b> function attempts to match pixel
            		formats that also have that flag or flags set. Otherwise, <b>ChoosePixelFormat</b> ignores that flag
            		in the pixel formats:<br/><br/>
            		PFD_DRAW_TO_WINDOW<br/>
            		PFD_DRAW_TO_BITMAP<br/>
            		PFD_SUPPORT_GDI<br/>
            		PFD_SUPPORT_OPENGL<br/><br/>
            		If any of the following flags are set, <b>ChoosePixelFormat</b> attempts to match pixel formats that
            		also have that flag or flags set. Otherwise, it attempts to match pixel formats without that flag set:<br/><br/>
            		PFD_DOUBLEBUFFER<br/>
            		PFD_STEREO<br/><br/>
            		If the following flag is set, the function ignores the PFD_DOUBLEBUFFER flag in the pixel formats:<br/><br/>
            		PFD_DOUBLEBUFFER_DONTCARE<br/><br/>
            		If the following flag is set, the function ignores the PFD_STEREO flag in the pixel formats:<br/><br/>
            		PFD_STEREO_DONTCARE<br/>
            	</para>
            	<para>
            		<b>iPixelType</b><br/>
            		Specifies the type of pixel format for the function to consider:<br/><br/>
            		PFD_TYPE_RGBA<br/>
            		PFD_TYPE_COLORINDEX<br/>
            	</para>
            	<para>
            		<b>cColorBits</b><br/>
            		Zero or greater.
            	</para>
            	<para>
            		<b>cRedBits</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>cRedShift</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>cGreenBits</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>cGreenShift</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>cBlueBits</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>cBlueShift</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>cAlphaBits</b><br/>
            		Zero or greater.
            	</para>
            	<para>
            		<b>cAlphaShift</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>cAccumBits</b><br/>
            		Zero or greater.
            	</para>
            	<para>
            		<b>cAccumRedBits</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>cAccumGreenBits</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>cAccumBlueBits</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>cAccumAlphaBits</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>cDepthBits</b><br/>
            		Zero or greater.
            	</para>
            	<para>
            		<b>cStencilBits</b><br/>
            		Zero or greater.
            	</para>
            	<para>
            		<b>cAuxBuffers</b><br/>
            		Zero or greater.
            	</para>
            	<para>
            		<b>iLayerType</b><br/>
            		Specifies one of the following layer type values:<br/><br/>
            		PFD_MAIN_PLANE<br/>
            		PFD_OVERLAY_PLANE<br/>
            		PFD_UNDERLAY_PLANE<br/>
            	</para>
            	<para>
            		<b>bReserved</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>dwLayerMask</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>dwVisibleMask</b><br/>
            		Not used.
            	</para>
            	<para>
            		<b>dwDamageMask</b><br/>
            		Not used.
            	</para>
             </param>
             <returns>
            		If the function succeeds, the return value is a pixel format index (one-based) that is the closest match
            		to the given pixel format descriptor.<br/><br/>
            		If the function fails, the return value is zero. To get extended error information,
            		call see cref="Kernel.GetLastError" /&gt;.
             </returns>
             <remarks>
            		You must ensure that the pixel format matched by the <b>ChoosePixelFormat</b> function satisfies your
            		requirements. For example, if you request a pixel format with a 24-bit RGB color buffer but the device
            		context offers only 8-bit RGB color buffers, the function returns a pixel format with an 8-bit RGB color
            		buffer.<br/><br/>
            		The following code sample shows how to use <b>ChoosePixelFormat</b> to match a specified pixel
            		format:<br/><br/>
            		<code>
            			HDC hdc;
            			int pixelFormat;
            			Gdi.PIXELFORMATDESCRIPTOR pfd;
            
            			// size of this pfd
            			pfd.nSize = (ushort) sizeof(Gdi.PIXELFORMATDESCRIPTOR);
            
            			// version number
            			pfd.nVersion = 1;
            
            			// support window, support OpenGL, double buffered
            			pfd.dwFlags = Gdi.PFD_DRAW_TO_WINDOW | Gdi.PFD_SUPPORT_OPENGL | Gdi.PFD_DOUBLEBUFFER;
            
            			// RGBA type
            			pfd.iPixelType = Gdi.PFD_TYPE_RGBA;
            
            			// 24-bit color depth
            			pfd.cColorBits = 24;
            
            			// color bits and shift bits ignored
            			pfd.cRedBits = 0;
            			pfd.cRedShift = 0;
            			pfd.cGreenBits = 0;
            			pfd.cGreenShift = 0;
            			pfd.cBlueBits = 0;
            			pfd.cBlueShift = 0;
            			pfd.cAlphaBits = 0;
            			pfd.cAlphaShift = 0;
            
            			// no accumulation buffer, accum bits ignored
            			pfd.cAccumBits = 0;
            			pfd.cAccumRedBits = 0;
            			pfd.cAccumGreenBits = 0;
            			pfd.cAccumBlueBits = 0;
            			pfd.cAccumAlphaBits = 0;
            
            			// no stencil buffer
            			pfd.cStencilBits = 0;
            
            			// no auxiliary buffer
            			pfd.cAuxBuffers = 0;
            
            			// main layer
            			pfd.iLayerType = Gdi.PFD_MAIN_PLANE;
            
            			// reserved
            			pfd.bReserved = 0;
            
            			// layer masks ignored
            			pfd.dwLayerMask = 0;
            			pfd.dwVisibleMask = 0;
            			pfd.dwDamageMask = 0;
            
            			pixelFormat = Gdi.ChoosePixelFormat(hdc, &amp;pfd);
            		</code>
             </remarks>
             seealso cref="DescribePixelFormat" /&gt;
             seealso cref="GetPixelFormat" /&gt;
             <seealso cref="M:Tao.Platform.Windows.Gdi.SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)">
             <summary>
             The <b>SetPixelFormat</b> function sets the pixel format of the specified device context to the format
             specified by the <i>iPixelFormat</i> index.
             </summary>
             <param name="deviceContext">
            		Specifies the device context whose pixel format the function attempts to set.
             </param>
             <param name="pixelFormat">
            		Index that identifies the pixel format to set. The various pixel formats supported by a device
            		context are identified by one-based indexes.
             </param>
             <param name="pixelFormatDescriptor">
            		Pointer to a <see cref="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR"/> structure that contains the logical pixel
            		format specification. The system's metafile component uses this structure to record the logical
            		pixel format specification. The structure has no other effect upon the behavior of the
            		<b>SetPixelFormat</b> function.
             </param>
             <returns>
            		If the function succeeds, the return value is true.<br/><br/>
            		If the function fails, the return value is false. To get extended error information, call
            		see cref="Kernel.GetLastError" /&gt;.
             </returns>
             <remarks>
            		If <i>hdc</i> references a window, calling the <b>SetPixelFormat</b> function also changes the pixel format
            		of the window. Setting the pixel format of a window more than once can lead to significant complications
            		for the Window Manager and for multithread applications, so it is not allowed. An application can only set
            		the pixel format of a window one time. Once a window's pixel format is set, it cannot be changed.<br/><br/>
            
            		You should select a pixel format in the device context before calling the <see cref="M:Tao.Platform.Windows.Wgl.wglCreateContext(System.IntPtr)"/>
            		function. The <b>wglCreateContext</b> function creates a rendering context for drawing on the device in the
            		selected pixel format of the device context.<br/><br/>
            
            		An OpenGL window has its own pixel format. Because of this, only device contexts retrieved for the client
            		area of an OpenGL window are allowed to draw into the window. As a result, an OpenGL window should be created
            		with the WS_CLIPCHILDREN and WS_CLIPSIBLINGS styles. Additionally, the window class attribute should not
            		include the CS_PARENTDC style.<br/><br/>
            
            		The following code example shows <b>SetPixelFormat</b> usage:<br/><br/>
            
            		<code>
            			HDC hdc;
            			int pixelFormat;
            			Gdi.PIXELFORMATDESCRIPTOR pfd;
            
            			// size of this pfd
            			pfd.nSize = (ushort) sizeof(Gdi.PIXELFORMATDESCRIPTOR);
            
            			// version number
            			pfd.nVersion = 1;
            
            			// support window, support OpenGL, double buffered
            			pfd.dwFlags = Gdi.PFD_DRAW_TO_WINDOW | Gdi.PFD_SUPPORT_OPENGL | Gdi.PFD_DOUBLEBUFFER;
            
            			// RGBA type
            			pfd.iPixelType = Gdi.PFD_TYPE_RGBA;
            
            			// 24-bit color depth
            			pfd.cColorBits = 24;
            
            			// color bits and shift bits ignored
            			pfd.cRedBits = 0;
            			pfd.cRedShift = 0;
            			pfd.cGreenBits = 0;
            			pfd.cGreenShift = 0;
            			pfd.cBlueBits = 0;
            			pfd.cBlueShift = 0;
            			pfd.cAlphaBits = 0;
            			pfd.cAlphaShift = 0;
            
            			// no accumulation buffer, accum bits ignored
            			pfd.cAccumBits = 0;
            			pfd.cAccumRedBits = 0;
            			pfd.cAccumGreenBits = 0;
            			pfd.cAccumBlueBits = 0;
            			pfd.cAccumAlphaBits = 0;
            
            			// no stencil buffer
            			pfd.cStencilBits = 0;
            
            			// no auxiliary buffer
            			pfd.cAuxBuffers = 0;
            
            			// main layer
            			pfd.iLayerType = Gdi.PFD_MAIN_PLANE;
            
            			// reserved
            			pfd.bReserved = 0;
            
            			// layer masks ignored
            			pfd.dwLayerMask = 0;
            			pfd.dwVisibleMask = 0;
            			pfd.dwDamageMask = 0;
            
            			pixelFormat = Gdi.ChoosePixelFormat(hdc, &amp;pfd);
            			
            			// make that the pixel format of the device context
            			Gdi.SetPixelFormat(hdc, pixelFormat, &amp;pfd);
            		</code>
             </remarks>
             <seealso cref="M:Tao.Platform.Windows.Gdi.ChoosePixelFormat(System.IntPtr,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>
             seealso cref="DescribePixelFormat" /&gt;
             seealso cref="GetPixelFormat" /&gt;
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.SwapBuffers(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="deviceContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.SwapBuffersFast(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="deviceContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.CreateFont(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="height"></param>
            <param name="width"></param>
            <param name="escapement"></param>
            <param name="orientation"></param>
            <param name="weight"></param>
            <param name="italic"></param>
            <param name="underline"></param>
            <param name="strikeOut"></param>
            <param name="charSet"></param>
            <param name="outputPrecision"></param>
            <param name="clipPrecision"></param>
            <param name="quality"></param>
            <param name="pitchAndFamily"></param>
            <param name="typeFace"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.DeleteObject(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="objectHandle"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.SelectObject(System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="deviceContext"></param>
            <param name="objectHandle"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Platform.Windows.Gdi.GetDeviceCaps(System.IntPtr,System.Int32)">
            <summary>
            Retrieves device-specific information for the specified device.
            </summary>
            <param name="deviceContext">Handle to the DC</param>
            <param name="nIndex">Specifies the item to return</param>
            <returns></returns>
        </member>
        <member name="T:Tao.Platform.Windows.Gdi.DEVMODE">
            <summary>
                <para>
                    The <b>DEVMODE</b> data structure contains information about the
                    initialization and environment of a printer or a display device.
                </para>
            </summary>
            <remarks>
                <para>
                    A device driver's private data follows the public portion of the
                    <b>DEVMODE</b> structure.  The size of the public data can vary for different
                    versions of the structure.  The <i>dmSize</i> member specifies the number of
                    bytes of public data, and the <i>dmDriverExtra</i> member specifies the
                    number of bytes of private data.
                </para>
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.User.ChangeDisplaySettings(Tao.Platform.Windows.Gdi.DEVMODE@,System.Int32)"/>
            <seealso cref="M:Tao.Platform.Windows.User.EnumDisplaySettings(System.String,System.Int32,Tao.Platform.Windows.Gdi.DEVMODE@)"/>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDeviceName">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmSpecVersion">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDriverVersion">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmSize">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDriverExtra">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmFields">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmOrientation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPaperSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPaperLength">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPaperWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmScale">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmCopies">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDefaultSource">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPrintQuality">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmColor">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDuplex">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmYResolution">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmTTOption">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmCollate">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmFormName">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmLogPixels">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmBitsPerPel">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsWidth">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPelsHeight">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFlags">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDisplayFrequency">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmICMMethod">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmICMIntent">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmMediaType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmDitherType">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmReserved1">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmReserved2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPanningWidth">
            <summary>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DEVMODE.dmPanningHeight">
            <summary>
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT">
            <summary>
            The <b>GLYPHMETRICSFLOAT</b> structure contains information about the placement and orientation of a glyph in a
            character cell.
            </summary>
            <remarks>The values of <b>GLYPHMETRICSFLOAT</b> are specified as notional units.</remarks>
            <seealso cref="T:Tao.Platform.Windows.Gdi.POINTFLOAT"/>
            <seealso cref="M:Tao.Platform.Windows.Wgl.wglUseFontOutlinesA(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT[])"/>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT.gmfBlackBoxX">
            <summary>
            Specifies the width of the smallest rectangle (the glyph's black box) that completely encloses the glyph.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT.gmfBlackBoxY">
            <summary>
            Specifies the height of the smallest rectangle (the glyph's black box) that completely encloses the glyph.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT.gmfptGlyphOrigin">
            <summary>
            Specifies the x and y coordinates of the upper-left corner of the smallest rectangle that completely encloses the glyph.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT.gmfCellIncX">
            <summary>
            Specifies the horizontal distance from the origin of the current character cell to the origin of the next character cell.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT.gmfCellIncY">
            <summary>
            Specifies the vertical distance from the origin of the current character cell to the origin of the next character cell.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR">
            <summary>
                The <b>PIXELFORMATDESCRIPTOR</b> structure describes the pixel format of a drawing surface.
            </summary>
            <remarks>
                Please notice carefully, as documented in the members, that certain pixel format properties are not supported
                in the current generic implementation. The generic implementation is the Microsoft GDI software
                implementation of OpenGL. Hardware manufacturers may enhance parts of OpenGL, and may support some
                pixel format properties not supported by the generic implementation.
            </remarks>
            <seealso cref="M:Tao.Platform.Windows.Gdi.ChoosePixelFormat(System.IntPtr,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>
            seealso cref="DescribePixelFormat" /&gt;
            seealso cref="GetPixelFormat" /&gt;
            <seealso cref="M:Tao.Platform.Windows.Gdi.SetPixelFormat(System.IntPtr,System.Int32,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.nSize">
            <summary>
            Specifies the size of this data structure. This value should be set to <c>sizeof(PIXELFORMATDESCRIPTOR)</c>.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.nVersion">
            <summary>
            Specifies the version of this data structure. This value should be set to 1.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.dwFlags">
            <summary>
            A set of bit flags that specify properties of the pixel buffer. The properties are generally not mutually exclusive;
            you can set any combination of bit flags, with the exceptions noted.
            </summary>
            <remarks>
                <para>The following bit flag constants are defined:</para>
                <list type="table">
            		<listheader>
            			<term>Value</term>
            			<description>Meaning</description>
            		</listheader>
            		<item>
            			<term>PFD_DRAW_TO_WINDOW</term>
            			<description>The buffer can draw to a window or device surface.</description>
            		</item>
            		<item>
            			<term>PFD_DRAW_TO_BITMAP</term>
            			<description>The buffer can draw to a memory bitmap.</description>
            		</item>
            		<item>
            			<term>PFD_SUPPORT_GDI</term>
            			<description>
            				The buffer supports GDI drawing. This flag and PFD_DOUBLEBUFFER are mutually exclusive
            				in the current generic implementation.
            			</description>
            		</item>
            		<item>
            			<term>PFD_SUPPORT_OPENGL</term>
            			<description>The buffer supports OpenGL drawing.</description>
            		</item>
            		<item>
            			<term>PFD_GENERIC_ACCELERATED</term>
            			<description>
            				The pixel format is supported by a device driver that accelerates the generic implementation.
            				If this flag is clear and the PFD_GENERIC_FORMAT flag is set, the pixel format is supported by
            				the generic implementation only.
            			</description>
            		</item>
            		<item>
            			<term>PFD_GENERIC_FORMAT</term>
            			<description>
            				The pixel format is supported by the GDI software implementation, which is also known as the
            				generic implementation. If this bit is clear, the pixel format is supported by a device
            				driver or hardware.
            			</description>
            		</item>
            		<item>
            			<term>PFD_NEED_PALETTE</term>
            			<description>
            				The buffer uses RGBA pixels on a palette-managed device. A logical palette is required to achieve
            				the best results for this pixel type. Colors in the palette should be specified according to the
            				values of the <b>cRedBits</b>, <b>cRedShift</b>, <b>cGreenBits</b>, <b>cGreenShift</b>,
            				<b>cBluebits</b>, and <b>cBlueShift</b> members. The palette should be created and realized in
            				the device context before calling <see cref="M:Tao.Platform.Windows.Wgl.wglMakeCurrent(System.IntPtr,System.IntPtr)"/>.
            			</description>
            		</item>
            		<item>
            			<term>PFD_NEED_SYSTEM_PALETTE</term>
            			<description>
            				Defined in the pixel format descriptors of hardware that supports one hardware palette in
            				256-color mode only. For such systems to use hardware acceleration, the hardware palette must be in
            				a fixed order (for example, 3-3-2) when in RGBA mode or must match the logical palette when in
            				color-index mode.
            				
            				When this flag is set, you must call SetSystemPaletteUse in your program to force a one-to-one
            				mapping of the logical palette and the system palette. If your OpenGL hardware supports multiple
            				hardware palettes and the device driver can allocate spare hardware palettes for OpenGL, this
            				flag is typically clear.
            				
            				This flag is not set in the generic pixel formats.
            			</description>
            		</item>
            		<item>
            			<term>PFD_DOUBLEBUFFER</term>
            			<description>
            				The buffer is double-buffered. This flag and PFD_SUPPORT_GDI are mutually exclusive in the
            				current generic implementation.
            			</description>
            		</item>
            		<item>
            			<term>PFD_STEREO</term>
            			<description>
            				The buffer is stereoscopic. This flag is not supported in the current generic implementation.
            			</description>
            		</item>
            		<item>
            			<term>PFD_SWAP_LAYER_BUFFERS</term>
            			<description>
            				Indicates whether a device can swap individual layer planes with pixel formats that include
            				double-buffered overlay or underlay planes. Otherwise all layer planes are swapped together
            				as a group. When this flag is set, <b>wglSwapLayerBuffers</b> is supported.
            			</description>
            		</item>
            	</list>
            	<para>You can specify the following bit flags when calling <see cref="M:Tao.Platform.Windows.Gdi.ChoosePixelFormat(System.IntPtr,Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR@)"/>.</para>
            	<list type="table">
            		<listheader>
            			<term>Value</term>
            			<description>Meaning</description>
            		</listheader>
            		<item>
            			<term>PFD_DEPTH_DONTCARE</term>
            			<description>
            				The requested pixel format can either have or not have a depth buffer. To select
            				a pixel format without a depth buffer, you must specify this flag. The requested pixel format
            				can be with or without a depth buffer. Otherwise, only pixel formats with a depth buffer
            				are considered.
            			</description>
            		</item>
            		<item>
            			<term>PFD_DOUBLEBUFFER_DONTCARE</term>
            			<description>The requested pixel format can be either single- or double-buffered.</description>
            		</item>
            		<item>
            			<term>PFD_STEREO_DONTCARE</term>
            			<description>The requested pixel format can be either monoscopic or stereoscopic.</description>
            		</item>
            	</list>
            	<para>
            		With the <b>glAddSwapHintRectWIN</b> extension function, two new flags are included for the
            		<b>PIXELFORMATDESCRIPTOR</b> pixel format structure.
            	</para>
            	<list type="table">
            		<listheader>
            			<term>Value</term>
            			<description>Meaning</description>
            		</listheader>
            		<item>
            			<term>PFD_SWAP_COPY</term>
            			<description>
            				Specifies the content of the back buffer in the double-buffered main color plane following
            				a buffer swap. Swapping the color buffers causes the content of the back buffer to be copied
            				to the front buffer. The content of the back buffer is not affected by the swap. PFD_SWAP_COPY
            				is a hint only and might not be provided by a driver.
            			</description>
            		</item>
            		<item>
            			<term>PFD_SWAP_EXCHANGE</term>
            			<description>
            				Specifies the content of the back buffer in the double-buffered main color plane following a
            				buffer swap. Swapping the color buffers causes the exchange of the back buffer's content
            				with the front buffer's content. Following the swap, the back buffer's content contains the
            				front buffer's content before the swap. PFD_SWAP_EXCHANGE is a hint only and might not be
            				provided by a driver.
            			</description>
            		</item>
            	</list>
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.iPixelType">
            <summary>
            Specifies the type of pixel data. The following types are defined.
            </summary>
            <remarks>
            	<list type="table">
            		<listheader>
            			<term>Value</term>
            			<description>Meaning</description>
            		</listheader>
            		<item>
            			<term>PFD_TYPE_RGBA</term>
            			<description>
            				RGBA pixels. Each pixel has four components in this order: red, green, blue, and alpha.
            			</description>
            		</item>
            		<item>
            			<term>PFD_TYPE_COLORINDEX</term>
            			<description>Color-index pixels. Each pixel uses a color-index value.</description>
            		</item>
            	</list>
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cColorBits">
            <summary>
            Specifies the number of color bitplanes in each color buffer. For RGBA pixel types, it is the size
            of the color buffer, excluding the alpha bitplanes. For color-index pixels, it is the size of the
            color-index buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cRedBits">
            <summary>
            Specifies the number of red bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cRedShift">
            <summary>
            Specifies the shift count for red bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cGreenBits">
            <summary>
            Specifies the number of green bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cGreenShift">
            <summary>
            Specifies the shift count for green bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cBlueBits">
            <summary>
            Specifies the number of blue bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cBlueShift">
            <summary>
            Specifies the shift count for blue bitplanes in each RGBA color buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAlphaBits">
            <summary>
            Specifies the number of alpha bitplanes in each RGBA color buffer. Alpha bitplanes are not supported.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAlphaShift">
            <summary>
            Specifies the shift count for alpha bitplanes in each RGBA color buffer. Alpha bitplanes are not supported.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAccumBits">
            <summary>
            Specifies the total number of bitplanes in the accumulation buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAccumRedBits">
            <summary>
            Specifies the number of red bitplanes in the accumulation buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAccumGreenBits">
            <summary>
            Specifies the number of green bitplanes in the accumulation buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAccumBlueBits">
            <summary>
            Specifies the number of blue bitplanes in the accumulation buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAccumAlphaBits">
            <summary>
            Specifies the number of alpha bitplanes in the accumulation buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cDepthBits">
            <summary>
            Specifies the depth of the depth (z-axis) buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cStencilBits">
            <summary>
            Specifies the depth of the stencil buffer.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.cAuxBuffers">
            <summary>
            Specifies the number of auxiliary buffers. Auxiliary buffers are not supported.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.iLayerType">
            <summary>
            Ignored. Earlier implementations of OpenGL used this member, but it is no longer used.
            </summary>
            <remarks>Specifies the type of layer.</remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.bReserved">
            <summary>
            Specifies the number of overlay and underlay planes. Bits 0 through 3 specify up to 15 overlay planes and
            bits 4 through 7 specify up to 15 underlay planes.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.dwLayerMask">
            <summary>
            Ignored. Earlier implementations of OpenGL used this member, but it is no longer used.
            </summary>
            <remarks>
            	Specifies the layer mask. The layer mask is used in conjunction with the visible mask to determine
            	if one layer overlays another.
            </remarks>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.dwVisibleMask">
            <summary>
            Specifies the transparent color or index of an underlay plane. When the pixel type is RGBA, <b>dwVisibleMask</b>
            is a transparent RGB color value. When the pixel type is color index, it is a transparent index value.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.PIXELFORMATDESCRIPTOR.dwDamageMask">
            <summary>
            Ignored. Earlier implementations of OpenGL used this member, but it is no longer used.
            </summary>
            <remarks>
            	Specifies whether more than one pixel format shares the same frame buffer. If the result of the bitwise
            	AND of the damage masks between two pixel formats is nonzero, then they share the same buffers.
            </remarks>
        </member>
        <member name="T:Tao.Platform.Windows.Gdi.POINTFLOAT">
            <summary>
            The <b>POINTFLOAT</b> structure contains the x and y coordinates of a point.
            </summary>
            <seealso cref="T:Tao.Platform.Windows.Gdi.GLYPHMETRICSFLOAT"/>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.POINTFLOAT.X">
            <summary>
            Specifies the horizontal (x) coordinate of a point.
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.POINTFLOAT.Y">
            <summary>
            Specifies the vertical (y) coordinate of a point.
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.nSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.nVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.dwFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.iPixelType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cColorBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cRedBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cRedShift">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cGreenBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cGreenShift">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cBlueBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cBlueShift">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cAlphaBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cAlphaShift">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cAccumBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cAccumRedBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cAccumGreenBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cAccumBlueBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cAccumAlphaBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cDepthBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cStencilBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.cAuxBuffers">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.iLayerPlane">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.bReserved">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.LAYERPLANEDESCRIPTOR.crTransparent">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Platform.Windows.Gdi.DevCaps">
            <summary>
            Flags for <see cref="M:Tao.Platform.Windows.Gdi.GetDeviceCaps(System.IntPtr,System.Int32)"/>
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.DRIVERVERSION">
            <summary>
            Device driver version
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.TECHNOLOGY">
            <summary>
            Device classification
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.HORZSIZE">
            <summary>
            Horizontal size in millimeters
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.VERTSIZE">
            <summary>
            Vertical size in millimeters
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.HORZRES">
            <summary>
            Horizontal width in pixels
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.VERTRES">
            <summary>
            Vertical height in pixels
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.BITSPIXEL">
            <summary>
            Number of bits per pixel
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.PLANES">
            <summary>
            Number of planes
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.NUMBRUSHES">
            <summary>
            Number of brushes the device has
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.NUMPENS">
            <summary>
            Number of pens the device has
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.NUMMARKERS">
            <summary>
            Number of markers the device has
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.NUMFONTS">
            <summary>
            Number of fonts the device has
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.NUMCOLORS">
            <summary>
            Number of colors the device supports
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.PDEVICESIZE">
            <summary>
            Size required for device descriptor
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.CURVECAPS">
            <summary>
            Curve capabilities
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.LINECAPS">
            <summary>
            Line capabilities
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.POLYGONALCAPS">
            <summary>
            Polygonal capabilities
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.TEXTCAPS">
            <summary>
            Text capabilities
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.CLIPCAPS">
            <summary>
            Clipping capabilities
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.RASTERCAPS">
            <summary>
            Bitblt capabilities
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.ASPECTX">
            <summary>
            Length of the X leg
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.ASPECTY">
            <summary>
            Length of the Y leg
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.ASPECTXY">
            <summary>
            Length of the hypotenuse
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.SHADEBLENDCAPS">
            <summary>
            Shading and Blending caps
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.LOGPIXELSX">
            <summary>
            Logical pixels inch in X
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.LOGPIXELSY">
            <summary>
            Logical pixels inch in Y
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.SIZEPALETTE">
            <summary>
            Number of entries in physical palette
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.NUMRESERVED">
            <summary>
            Number of reserved entries in palette
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.COLORRES">
            <summary>
            Actual color resolution
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.PHYSICALWIDTH">
            <summary>
            Physical Width in device units
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.PHYSICALHEIGHT">
            <summary>
            Physical Height in device units
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.PHYSICALOFFSETX">
            <summary>
            Physical Printable Area x margin
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.PHYSICALOFFSETY">
            <summary>
            Physical Printable Area y margin
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.SCALINGFACTORX">
            <summary>
            Scaling factor x
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.SCALINGFACTORY">
            <summary>
            Scaling factor y
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.VREFRESH">
            <summary>
            Current vertical refresh rate of the display device (for displays only) in Hz
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.DESKTOPVERTRES">
            <summary>
            Horizontal width of entire desktop in pixels
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.DESKTOPHORZRES">
            <summary>
            Vertical height of entire desktop in pixels
            </summary>
        </member>
        <member name="F:Tao.Platform.Windows.Gdi.DevCaps.BLTALIGNMENT">
            <summary>
            Preferred blt alignment
            </summary>
        </member>
    </members>
</doc>
